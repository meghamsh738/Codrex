from fastapi import FastAPI, HTTPException, Body, UploadFile, File, Form, Request
from fastapi.responses import HTMLResponse, Response, FileResponse, JSONResponse, StreamingResponse, RedirectResponse
import asyncio
import json
import time
import os
import subprocess
import socket
import io
import re
import html as html_std
import threading
import uuid
import posixpath
import secrets
import ctypes
from ctypes import wintypes
from typing import List, Dict, Any, Optional, Tuple

from mss import mss
from mss.tools import to_png

START_TIME = time.time()
app = FastAPI(title="Codrex Remote UI", version="1.2.0")

WSL_DISTRO = os.environ.get("CODEX_WSL_DISTRO", "Ubuntu")
WSL_EXE = os.environ.get("CODEX_WSL_EXE", "wsl")
CODEX_WORKDIR = os.environ.get("CODEX_WORKDIR", "/home/megha/codrex-work")
CODEX_AUTH_TOKEN = os.environ.get("CODEX_AUTH_TOKEN", "").strip()
CODEX_AUTH_COOKIE = os.environ.get("CODEX_AUTH_COOKIE", "codrex_remote_auth").strip() or "codrex_remote_auth"
CODEX_DESKTOP_MODE_COOKIE = os.environ.get("CODEX_DESKTOP_MODE_COOKIE", "codrex_remote_desktop_mode").strip() or "codrex_remote_desktop_mode"
CODEX_AUTH_REQUIRED = bool(CODEX_AUTH_TOKEN)
BLANK_IMAGE_DATA_URL = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs="

# Pairing codes are short-lived one-time secrets used to authenticate a second device (phone/tablet)
# without typing the long CODEX_AUTH_TOKEN. They are only generated by an already-authenticated client.
PAIRING_TTL_SECONDS = int(os.environ.get("CODEX_PAIRING_TTL_SECONDS", "90"))
PAIRING_LOCK = threading.Lock()
PAIRING_CODES: Dict[str, float] = {}

def pairing_create_code() -> Dict[str, Any]:
    code = secrets.token_urlsafe(18)
    now = time.time()
    expires_at = now + max(10, PAIRING_TTL_SECONDS)
    with PAIRING_LOCK:
        # Best-effort cleanup of expired entries.
        for k, exp in list(PAIRING_CODES.items()):
            if exp <= now:
                PAIRING_CODES.pop(k, None)
        PAIRING_CODES[code] = expires_at
    return {"code": code, "expires_in": int(expires_at - now)}

def pairing_consume_code(code: str) -> bool:
    if not code:
        return False
    now = time.time()
    with PAIRING_LOCK:
        exp = PAIRING_CODES.get(code)
        if not exp:
            return False
        if exp <= now:
            PAIRING_CODES.pop(code, None)
            return False
        PAIRING_CODES.pop(code, None)
    return True

def _tailscale_exe_path() -> str:
    if os.name != "nt":
        return ""
    pf = os.environ.get("ProgramFiles", r"C:\Program Files")
    pf86 = os.environ.get("ProgramFiles(x86)", r"C:\Program Files (x86)")
    candidates = [
        os.path.join(pf, "Tailscale", "tailscale.exe"),
        os.path.join(pf86, "Tailscale", "tailscale.exe"),
    ]
    for p in candidates:
        if os.path.exists(p):
            return p
    return ""

def get_tailscale_ipv4() -> str:
    if os.name != "nt":
        return ""
    exe = _tailscale_exe_path()
    if not exe:
        return ""
    try:
        out = subprocess.check_output([exe, "ip", "-4"], text=True, timeout=5).strip()
        ip = (out.splitlines()[0].strip() if out else "")
        if re.match(r"^\d+\.\d+\.\d+\.\d+$", ip):
            return ip
    except Exception:
        return ""
    return ""

def guess_lan_ipv4() -> str:
    # Works on Windows and Linux. Doesn't actually send packets, just picks the default route.
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))
        ip = s.getsockname()[0]
        s.close()
        return ip
    except Exception:
        return ""

# WSL file access is restricted to this root by default (safer).
# You can widen later by setting CODEX_FILE_ROOT to e.g. "/home/megha"
CODEX_FILE_ROOT = os.environ.get("CODEX_FILE_ROOT", CODEX_WORKDIR)

VALID_NAME_RE = re.compile(r"^[A-Za-z0-9_.-]+$")
VALID_PANE_RE = re.compile(r"^%\d+$")

# -------------------------
# Small in-memory run store
# -------------------------
RUNS_LOCK = threading.Lock()
RUNS: Dict[str, Dict[str, Any]] = {}
RUNS_ORDER: List[str] = []
MAX_RUNS_KEEP = 50
MAX_CONCURRENT_RUNS = 2
MAX_DESKTOP_TEXT = 2000
SHOW_CURSOR_OVERLAY = os.environ.get("CODEX_SHOW_CURSOR_OVERLAY", "1").strip().lower() not in {"0", "false", "no"}
DESKTOP_STREAM_FPS_DEFAULT = float(os.environ.get("CODEX_DESKTOP_STREAM_FPS", "3.0") or "3.0")
DESKTOP_STREAM_PNG_LEVEL_DEFAULT = int(os.environ.get("CODEX_DESKTOP_STREAM_PNG_LEVEL", "3") or "3")


def _overlay_cursor_rgb(rgb_bytes: bytes, size: Tuple[int, int], x: int, y: int) -> bytes:
    """
    MSS screenshots typically do not include the OS cursor. For mobile remote control,
    we overlay a visible cursor marker into the PNG bytes.
    """
    w, h = int(size[0]), int(size[1])
    if not rgb_bytes or w <= 0 or h <= 0:
        return rgb_bytes
    expected = w * h * 3
    if len(rgb_bytes) < expected:
        return rgb_bytes

    buf = bytearray(rgb_bytes)

    def set_px(px: int, py: int, r: int, g: int, b: int) -> None:
        if px < 0 or py < 0 or px >= w or py >= h:
            return
        i = (py * w + px) * 3
        buf[i] = r
        buf[i + 1] = g
        buf[i + 2] = b

    cx, cy = int(x), int(y)
    if cx < 0 or cy < 0 or cx >= w or cy >= h:
        return rgb_bytes

    # Outer black crosshair for contrast on bright backgrounds.
    for i in range(-12, 13):
        for t in (-1, 0, 1):
            set_px(cx + i, cy + t, 0, 0, 0)
            set_px(cx + t, cy + i, 0, 0, 0)

    # Inner cyan crosshair.
    for i in range(-10, 11):
        set_px(cx + i, cy, 0, 255, 255)
        set_px(cx, cy + i, 0, 255, 255)

    # Center red dot.
    for dx in (-1, 0, 1):
        for dy in (-1, 0, 1):
            set_px(cx + dx, cy + dy, 255, 0, 0)

    return bytes(buf)


def _desktop_cursor_pos() -> Optional[Tuple[int, int]]:
    if os.name != "nt":
        return None
    user32 = _win_user32()
    try:
        pt = wintypes.POINT()
        ok = user32.GetCursorPos(ctypes.byref(pt))
        if not ok:
            return None
        return int(pt.x), int(pt.y)
    except Exception:
        return None


ULONG_PTR = getattr(wintypes, "ULONG_PTR", ctypes.c_size_t)

INPUT_MOUSE = 0
INPUT_KEYBOARD = 1
INPUT_HARDWARE = 2

KEYEVENTF_EXTENDEDKEY = 0x0001
KEYEVENTF_KEYUP = 0x0002
KEYEVENTF_UNICODE = 0x0004

VK_BACK = 0x08
VK_TAB = 0x09
VK_RETURN = 0x0D
VK_ESCAPE = 0x1B
VK_DELETE = 0x2E
VK_SPACE = 0x20

VK_CONTROL = 0x11
VK_MENU = 0x12  # Alt
VK_HOME = 0x24
VK_END = 0x23
VK_PRIOR = 0x21  # Page Up
VK_NEXT = 0x22   # Page Down
VK_LEFT = 0x25
VK_UP = 0x26
VK_RIGHT = 0x27
VK_DOWN = 0x28
VK_F5 = 0x74


class MOUSEINPUT(ctypes.Structure):
    _fields_ = [
        ("dx", wintypes.LONG),
        ("dy", wintypes.LONG),
        ("mouseData", wintypes.DWORD),
        ("dwFlags", wintypes.DWORD),
        ("time", wintypes.DWORD),
        ("dwExtraInfo", ULONG_PTR),
    ]


class KEYBDINPUT(ctypes.Structure):
    _fields_ = [
        ("wVk", wintypes.WORD),
        ("wScan", wintypes.WORD),
        ("dwFlags", wintypes.DWORD),
        ("time", wintypes.DWORD),
        ("dwExtraInfo", ULONG_PTR),
    ]


class HARDWAREINPUT(ctypes.Structure):
    _fields_ = [
        ("uMsg", wintypes.DWORD),
        ("wParamL", wintypes.WORD),
        ("wParamH", wintypes.WORD),
    ]


class INPUT_UNION(ctypes.Union):
    _fields_ = [
        ("mi", MOUSEINPUT),
        ("ki", KEYBDINPUT),
        ("hi", HARDWAREINPUT),
    ]


class INPUT(ctypes.Structure):
    _fields_ = [
        ("type", wintypes.DWORD),
        ("union", INPUT_UNION),
    ]


def _win_send_input() -> Any:
    _ensure_windows_host()
    user32 = _win_user32()
    if not hasattr(_win_send_input, "_configured"):
        user32.SendInput.argtypes = [wintypes.UINT, ctypes.POINTER(INPUT), ctypes.c_int]
        user32.SendInput.restype = wintypes.UINT
        _win_send_input._configured = True  # type: ignore[attr-defined]
    return user32.SendInput


def _send_inputs(inputs: List[INPUT]) -> None:
    send_input = _win_send_input()
    arr = (INPUT * len(inputs))(*inputs)
    sent = int(send_input(len(inputs), arr, ctypes.sizeof(INPUT)))
    if sent != len(inputs):
        raise HTTPException(status_code=500, detail="Failed to send keyboard input.")


def _send_vk(vk: int, extended: bool = False) -> None:
    flags = KEYEVENTF_EXTENDEDKEY if extended else 0
    down = INPUT(type=INPUT_KEYBOARD, union=INPUT_UNION(ki=KEYBDINPUT(wVk=vk, wScan=0, dwFlags=flags, time=0, dwExtraInfo=0)))
    up = INPUT(type=INPUT_KEYBOARD, union=INPUT_UNION(ki=KEYBDINPUT(wVk=vk, wScan=0, dwFlags=flags | KEYEVENTF_KEYUP, time=0, dwExtraInfo=0)))
    _send_inputs([down, up])

def _send_vk_repeat(vk: int, count: int, extended: bool = False) -> None:
    n = int(count)
    if n <= 0:
        return
    if n > 200:
        raise HTTPException(status_code=400, detail="Key repeat too large (max 200).")
    flags = KEYEVENTF_EXTENDEDKEY if extended else 0
    inputs: List[INPUT] = []
    for _ in range(n):
        down = INPUT(type=INPUT_KEYBOARD, union=INPUT_UNION(ki=KEYBDINPUT(wVk=vk, wScan=0, dwFlags=flags, time=0, dwExtraInfo=0)))
        up = INPUT(type=INPUT_KEYBOARD, union=INPUT_UNION(ki=KEYBDINPUT(wVk=vk, wScan=0, dwFlags=flags | KEYEVENTF_KEYUP, time=0, dwExtraInfo=0)))
        inputs.append(down)
        inputs.append(up)
    _send_inputs(inputs)


def _send_vk_combo(modifiers: List[int], vk: int, extended: bool = False) -> None:
    """
    Send modifier combo reliably with native SendInput.
    Example: Ctrl+A -> modifiers=[VK_CONTROL], vk=0x41
    """
    seq: List[INPUT] = []
    for mod in modifiers:
        seq.append(INPUT(type=INPUT_KEYBOARD, union=INPUT_UNION(ki=KEYBDINPUT(wVk=mod, wScan=0, dwFlags=0, time=0, dwExtraInfo=0))))
    flags = KEYEVENTF_EXTENDEDKEY if extended else 0
    seq.append(INPUT(type=INPUT_KEYBOARD, union=INPUT_UNION(ki=KEYBDINPUT(wVk=vk, wScan=0, dwFlags=flags, time=0, dwExtraInfo=0))))
    seq.append(INPUT(type=INPUT_KEYBOARD, union=INPUT_UNION(ki=KEYBDINPUT(wVk=vk, wScan=0, dwFlags=flags | KEYEVENTF_KEYUP, time=0, dwExtraInfo=0))))
    for mod in reversed(modifiers):
        seq.append(INPUT(type=INPUT_KEYBOARD, union=INPUT_UNION(ki=KEYBDINPUT(wVk=mod, wScan=0, dwFlags=KEYEVENTF_KEYUP, time=0, dwExtraInfo=0))))
    _send_inputs(seq)


def _send_unicode_text(text: str) -> None:
    if not text:
        return
    # Send UTF-16 code units to support characters outside the BMP (surrogate pairs).
    data = text.encode("utf-16-le", errors="strict")
    inputs: List[INPUT] = []
    for i in range(0, len(data), 2):
        code_unit = int.from_bytes(data[i:i + 2], "little")
        down = INPUT(type=INPUT_KEYBOARD, union=INPUT_UNION(ki=KEYBDINPUT(wVk=0, wScan=code_unit, dwFlags=KEYEVENTF_UNICODE, time=0, dwExtraInfo=0)))
        up = INPUT(type=INPUT_KEYBOARD, union=INPUT_UNION(ki=KEYBDINPUT(wVk=0, wScan=code_unit, dwFlags=KEYEVENTF_UNICODE | KEYEVENTF_KEYUP, time=0, dwExtraInfo=0)))
        inputs.append(down)
        inputs.append(up)
    _send_inputs(inputs)

# -------------------------
# Live codex session state
# -------------------------
SESSIONS_LOCK = threading.Lock()
SESSIONS: Dict[str, Dict[str, Any]] = {}

def _validate_session_name(name: str) -> str:
    if not VALID_NAME_RE.fullmatch(name or ""):
        raise HTTPException(status_code=400, detail="Invalid session name format.")
    return name

def _validate_pane_id(pane_id: str) -> str:
    if not VALID_PANE_RE.fullmatch(pane_id or ""):
        raise HTTPException(status_code=400, detail="Invalid pane id format.")
    return pane_id

def _bash_quote(s: str) -> str:
    return "'" + s.replace("'", "'\"'\"'") + "'"

def _tmux_server_running(stderr: str) -> bool:
    s = (stderr or "").lower()
    return not ("no server running" in s or "failed to connect to server" in s)

WIN_INTERRUPT_EXIT_CODES = {3221225786, -1073741510}  # 0xC000013A (Ctrl+C / console interrupt)

def _is_windows_interrupt(exit_code: Optional[int]) -> bool:
    if exit_code is None:
        return False
    return exit_code in WIN_INTERRUPT_EXIT_CODES

def _wsl_run_kwargs() -> Dict[str, Any]:
    kwargs: Dict[str, Any] = {}
    if os.name != "nt":
        return kwargs

    creationflags = 0
    creationflags |= getattr(subprocess, "CREATE_NEW_PROCESS_GROUP", 0)
    # Avoid DETACHED_PROCESS because it breaks stdout capture for wsl.exe.
    creationflags |= getattr(subprocess, "CREATE_NO_WINDOW", 0)

    if creationflags:
        kwargs["creationflags"] = creationflags

    if hasattr(subprocess, "STARTUPINFO"):
        startupinfo = subprocess.STARTUPINFO()
        if hasattr(subprocess, "STARTF_USESHOWWINDOW"):
            startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
            startupinfo.wShowWindow = 0
        kwargs["startupinfo"] = startupinfo

    kwargs["stdin"] = subprocess.DEVNULL
    return kwargs

def _wsl_executable() -> str:
    if os.name != "nt":
        return WSL_EXE
    if WSL_EXE and WSL_EXE != "wsl":
        return WSL_EXE
    windir = os.environ.get("WINDIR", r"C:\Windows")
    sys32_wsl = os.path.join(windir, "System32", "wsl.exe")
    if os.path.exists(sys32_wsl):
        return sys32_wsl
    return "wsl"

def run_wsl_bash(command: str, timeout_s: int = 30) -> Dict[str, Any]:
    args = [_wsl_executable(), "-d", WSL_DISTRO, "--", "bash", "-lc", command]
    max_attempts = 2 if os.name == "nt" else 1
    attempt = 0
    while attempt < max_attempts:
        attempt += 1
        try:
            p = subprocess.run(
                args,
                capture_output=True,
                text=True,
                encoding="utf-8",
                errors="replace",
                timeout=timeout_s,
                **_wsl_run_kwargs(),
            )
            if os.name == "nt" and _is_windows_interrupt(p.returncode) and attempt < max_attempts:
                time.sleep(0.2)
                continue
            result = {
                "exit_code": p.returncode,
                "stdout": (p.stdout or "").rstrip(),
                "stderr": (p.stderr or "").rstrip(),
                "attempts": attempt,
            }
            if os.name == "nt" and _is_windows_interrupt(p.returncode):
                result["error"] = "interrupted"
            return result
        except subprocess.TimeoutExpired:
            return {"exit_code": 124, "stdout": "", "stderr": f"timeout after {timeout_s}s", "attempts": attempt}
        except Exception as e:
            return {"exit_code": 125, "stdout": "", "stderr": f"exception: {type(e).__name__}: {e}", "attempts": attempt}

# -------------------------
# WSL path helpers (restricted to CODEX_FILE_ROOT)
# -------------------------
def _norm_posix(p: str) -> str:
    return posixpath.normpath(p).replace("\\", "/")

def _resolve_wsl_path(user_path: str) -> str:
    """
    Resolve a user-provided path into an absolute WSL path under CODEX_FILE_ROOT.
    - If user_path starts with '/', treat it as absolute but still require it stays under root.
    - Otherwise treat it as relative to CODEX_FILE_ROOT.
    """
    if not user_path:
        raise HTTPException(status_code=400, detail="Missing path.")
    root = _norm_posix(CODEX_FILE_ROOT)
    if not root.startswith("/"):
        raise HTTPException(status_code=500, detail="CODEX_FILE_ROOT must be an absolute WSL path.")

    p = user_path.strip()
    if p.startswith("/"):
        resolved = _norm_posix(p)
    else:
        resolved = _norm_posix(posixpath.join(root, p))

    # enforce root containment
    if resolved != root and not resolved.startswith(root.rstrip("/") + "/"):
        raise HTTPException(status_code=403, detail=f"Path is outside allowed root: {root}")

    return resolved

def _wsl_unc_path(wsl_abs_path: str) -> str:
    # Convert /home/megha/x -> \\wsl$\Ubuntu\home\megha\x
    if not wsl_abs_path.startswith("/"):
        raise HTTPException(status_code=500, detail="Internal error: expected absolute WSL path.")
    return r"\\wsl$\%s%s" % (WSL_DISTRO, wsl_abs_path.replace("/", "\\"))

# -------------------------
# Auth helpers
# -------------------------
def _auth_token_from_request(request: Request) -> str:
    return (
        request.headers.get("x-auth-token")
        or request.cookies.get(CODEX_AUTH_COOKIE)
        or ""
    ).strip()

def _is_valid_auth_token(token: str) -> bool:
    if not CODEX_AUTH_REQUIRED:
        return True
    if not token:
        return False
    return secrets.compare_digest(token, CODEX_AUTH_TOKEN)

def _truthy_flag(v: Any) -> bool:
    return str(v or "").strip().lower() in {"1", "true", "yes", "on"}

def _falsy_flag(v: Any) -> bool:
    return str(v or "").strip().lower() in {"0", "false", "no", "off"}

def _desktop_enabled_from_request(request: Request) -> bool:
    # Query param can temporarily override cookie value on this request.
    q = ""
    try:
        q = (request.query_params.get("desktop") or "").strip().lower()
    except Exception:
        q = ""
    if _truthy_flag(q):
        return True
    if _falsy_flag(q):
        return False

    c = (request.cookies.get(CODEX_DESKTOP_MODE_COOKIE) or "").strip().lower()
    if _truthy_flag(c):
        return True
    if _falsy_flag(c):
        return False
    return True


def _compact_enabled_from_request(request: Request) -> bool:
    q = ""
    try:
        q = (request.query_params.get("compact") or "").strip().lower()
    except Exception:
        q = ""
    if _truthy_flag(q):
        return True
    if q in {"m", "mobile"}:
        return True
    if _falsy_flag(q):
        return False
    return False

@app.middleware("http")
async def auth_middleware(request: Request, call_next):
    if not CODEX_AUTH_REQUIRED:
        return await call_next(request)

    path = request.url.path
    public_paths = {
        "/",
        "/mobile",
        "/diag/js",
        "/diag/status",
        "/favicon.ico",
        "/auth/login",
        "/auth/logout",
        "/auth/status",
        "/auth/pair/exchange",
        "/auth/pair/consume",
        "/legacy/auth",
        "/legacy/auth/login",
        "/legacy/auth/logout",
        "/docs",
        "/redoc",
        "/openapi.json",
    }
    if path in public_paths:
        return await call_next(request)

    token = _auth_token_from_request(request)
    if not _is_valid_auth_token(token):
        resp = JSONResponse(
            status_code=401,
            content={"ok": False, "error": "unauthorized", "detail": "Login required."},
        )
        # Avoid caching 401 responses (some mobile browsers can be sticky about subresource failures).
        resp.headers["Cache-Control"] = "no-store"
        return resp
    return await call_next(request)


@app.get("/mobile")
def mobile_entry():
    resp = RedirectResponse(url="/?compact=1", status_code=307)
    resp.headers["Cache-Control"] = "no-store"
    return resp

# -------------------------
# Desktop control helpers
# -------------------------
def _ensure_windows_host() -> None:
    if os.name != "nt":
        raise HTTPException(status_code=400, detail="Desktop control is only supported on Windows hosts.")

def _desktop_monitor() -> Dict[str, int]:
    with mss() as sct:
        mon = sct.monitors[1] if len(sct.monitors) > 1 else sct.monitors[0]
        return {
            "left": int(mon.get("left", 0)),
            "top": int(mon.get("top", 0)),
            "width": int(mon.get("width", 0)),
            "height": int(mon.get("height", 0)),
        }

def _clamp(v: int, lo: int, hi: int) -> int:
    return max(lo, min(hi, v))

def _desktop_point(x: int, y: int) -> Dict[str, int]:
    mon = _desktop_monitor()
    if mon["width"] <= 0 or mon["height"] <= 0:
        raise HTTPException(status_code=500, detail="Invalid desktop monitor size.")
    sx = _clamp(int(x), 0, mon["width"] - 1)
    sy = _clamp(int(y), 0, mon["height"] - 1)
    return {
        "x": mon["left"] + sx,
        "y": mon["top"] + sy,
        "rel_x": sx,
        "rel_y": sy,
        **mon,
    }

def _win_user32():
    _ensure_windows_host()
    return ctypes.windll.user32

def _desktop_move_abs(x: int, y: int) -> None:
    user32 = _win_user32()
    user32.SetCursorPos(int(x), int(y))

def _desktop_click(button: str = "left", double: bool = False) -> None:
    user32 = _win_user32()
    btn = (button or "left").strip().lower()
    mapping = {
        "left": (0x0002, 0x0004),
        "right": (0x0008, 0x0010),
        "middle": (0x0020, 0x0040),
    }
    if btn not in mapping:
        raise HTTPException(status_code=400, detail="Unsupported mouse button.")
    down, up = mapping[btn]
    times = 2 if double else 1
    for _ in range(times):
        user32.mouse_event(down, 0, 0, 0, 0)
        user32.mouse_event(up, 0, 0, 0, 0)

def _desktop_scroll(delta: int) -> None:
    user32 = _win_user32()
    user32.mouse_event(0x0800, 0, 0, int(delta), 0)

def _run_powershell(script: str, timeout_s: int = 10) -> Dict[str, Any]:
    _ensure_windows_host()
    try:
        p = subprocess.run(
            ["powershell", "-NoProfile", "-Command", script],
            capture_output=True,
            text=True,
            timeout=timeout_s,
            encoding="utf-8",
            errors="replace",
        )
        return {
            "exit_code": p.returncode,
            "stdout": (p.stdout or "").rstrip(),
            "stderr": (p.stderr or "").rstrip(),
        }
    except subprocess.TimeoutExpired:
        return {"exit_code": 124, "stdout": "", "stderr": f"timeout after {timeout_s}s"}
    except Exception as e:
        return {"exit_code": 125, "stdout": "", "stderr": f"exception: {type(e).__name__}: {e}"}

def _desktop_send_text(text: str) -> Dict[str, Any]:
    # Clipboard + Ctrl+V handles large text and special chars better than raw SendKeys.
    if len(text) > MAX_DESKTOP_TEXT:
        raise HTTPException(status_code=400, detail=f"Text too long (max {MAX_DESKTOP_TEXT}).")
    script = (
        "Add-Type -AssemblyName System.Windows.Forms; "
        "$txt = @'\n"
        + text
        + "\n'@; "
        "Set-Clipboard -Value $txt; "
        "[System.Windows.Forms.SendKeys]::SendWait('^v')"
    )
    return _run_powershell(script, timeout_s=10)

def _desktop_send_key(key: str) -> Dict[str, Any]:
    k = (key or "").strip().lower()
    native_vk = {
        "enter": VK_RETURN,
        "esc": VK_ESCAPE,
        "tab": VK_TAB,
        "backspace": VK_BACK,
        "delete": VK_DELETE,
        "up": VK_UP,
        "down": VK_DOWN,
        "left": VK_LEFT,
        "right": VK_RIGHT,
        "home": VK_HOME,
        "end": VK_END,
        "pgup": VK_PRIOR,
        "pgdn": VK_NEXT,
        "f5": VK_F5,
        "space": VK_SPACE,
    }
    if k in native_vk:
        _send_vk(native_vk[k], extended=(k in {"delete", "up", "down", "left", "right", "home", "end", "pgup", "pgdn"}))
        return {"exit_code": 0, "stdout": "", "stderr": "", "mode": "native", "key": k}

    native_combos = {
        "ctrl+a": ([VK_CONTROL], 0x41),
        "ctrl+c": ([VK_CONTROL], 0x43),
        "ctrl+v": ([VK_CONTROL], 0x56),
        "ctrl+x": ([VK_CONTROL], 0x58),
        "ctrl+z": ([VK_CONTROL], 0x5A),
        "alt+tab": ([VK_MENU], VK_TAB),
    }
    if k in native_combos:
        mods, vk = native_combos[k]
        _send_vk_combo(mods, vk, extended=(k == "alt+tab"))
        return {"exit_code": 0, "stdout": "", "stderr": "", "mode": "native_combo", "key": k}

    # Fallback to SendKeys for uncommon special-key specs.
    ps_key_map = {
        "printscreen": "{PRTSC}",
    }
    spec = ps_key_map.get(k)
    if not spec:
        raise HTTPException(status_code=400, detail="Unsupported key. Try: enter, esc, tab, arrows, ctrl+c.")
    script = "Add-Type -AssemblyName System.Windows.Forms; " + f"[System.Windows.Forms.SendKeys]::SendWait('{spec}')"
    r = _run_powershell(script, timeout_s=8)
    r["mode"] = "powershell_sendkeys"
    r["key"] = k
    return r

# -------------------------
# Codex session helpers
# -------------------------
def _tmux_list_panes(session: Optional[str] = None) -> List[Dict[str, Any]]:
    if session:
        _validate_session_name(session)
        cmd = (
            "tmux list-panes -t " + session +
            " -F '#{session_name}\\t#{window_index}\\t#{pane_index}\\t#{pane_id}\\t#{pane_active}\\t#{pane_current_command}\\t#{pane_current_path}'"
        )
    else:
        cmd = (
            "tmux list-panes -a "
            "-F '#{session_name}\\t#{window_index}\\t#{pane_index}\\t#{pane_id}\\t#{pane_active}\\t#{pane_current_command}\\t#{pane_current_path}'"
        )
    r = run_wsl_bash(cmd)
    if r.get("exit_code") != 0:
        return []
    panes: List[Dict[str, Any]] = []
    for line in (r.get("stdout") or "").splitlines():
        parts = line.replace("\\t", "\t").split("\t")
        if len(parts) >= 7:
            panes.append({
                "session": parts[0],
                "window_index": parts[1],
                "pane_index": parts[2],
                "pane_id": parts[3],
                "active": parts[4] == "1",
                "current_command": parts[5],
                "current_path": parts[6],
            })
    return panes

def _infer_progress_state(text: str, current_command: str = "") -> str:
    t = (text or "").lower()
    cc = (current_command or "").lower()
    # Codex renders live progress lines like:
    #   "◦ Working (2s • esc to interrupt)"
    #   "Interpreting user request (12s • esc to interrupt)"
    if ("working (" in t) or ("esc to interrupt" in t):
        return "running"
    if any(x in t for x in ["approve", "approval", "press enter", "y/n", "continue?"]):
        return "waiting"

    # Avoid false "error" states from non-fatal MCP startup warnings that often contain
    # the word "failed".
    mcp_warning = ("mcp" in t) and any(x in t for x in ["mcp client", "mcp startup incomplete", "starting mcp servers"])

    # Only treat these as hard errors.
    if any(x in t for x in ["traceback", "exception", "panic", "segmentation fault"]):
        return "error"
    if not mcp_warning and any(x in t for x in ["error", "failed"]):
        return "error"
    if any(x in t for x in ["done", "completed", "all set", "finished"]):
        return "done"
    # Codex often runs under `node` in tmux; treat that as idle unless we saw explicit progress above.
    if cc == "node":
        return "idle"
    # If tmux reports the command as `codex`, it's reasonable to treat it as running.
    if cc == "codex":
        return "running"
    if cc and cc not in {"bash", "zsh", "sh", "fish"}:
        return "running"
    return "idle"

def _capture_snippet(pane_id: str, lines: int = 60) -> str:
    pane_id = _validate_pane_id(pane_id)
    r = run_wsl_bash(f"tmux capture-pane -t {pane_id} -p -J -S -{int(lines)}", timeout_s=15)
    if r.get("exit_code") != 0:
        return ""
    out = (r.get("stdout") or "").strip()
    if not out:
        return ""
    lines_arr = out.splitlines()
    return "\n".join(lines_arr[-12:])

def _capture_pane_full(pane_id: str, max_chars: int = 20000) -> str:
    pane_id = _validate_pane_id(pane_id)
    # Prefer alternate-screen, which is where TUIs (Codex) typically render.
    r = run_wsl_bash(f"tmux capture-pane -t {pane_id} -a -p -J", timeout_s=30)
    if r.get("exit_code") != 0 and ("no alternate screen" in (r.get("stderr") or "").lower()):
        r = run_wsl_bash(f"tmux capture-pane -t {pane_id} -p -J -S -20000", timeout_s=30)
    if r.get("exit_code") != 0:
        return ""
    txt = r.get("stdout") or ""
    if max_chars and len(txt) > max_chars:
        # Keep the tail, which is where the latest assistant output usually is.
        txt = txt[-max_chars:]
    return txt.strip("\n")

def _pane_is_codex_like(pane_id: str) -> bool:
    """
    Best-effort detection for panes that are running the Codex TUI.

    Why: Codex uses multi-line input where submission is "Enter on an empty line",
    which often needs an extra Enter (and a tiny delay). Regular shells generally
    want a single Enter.
    """
    try:
        panes = _tmux_list_panes()
    except Exception:
        panes = []
    for p in panes:
        if p.get("pane_id") != pane_id:
            continue
        sess = (p.get("session") or "").strip().lower()
        cc = (p.get("current_command") or "").strip().lower()
        if sess.startswith("codex"):
            return True
        if cc == "codex":
            return True
    return False

def _safe_name(name: str) -> str:
    x = re.sub(r"[^A-Za-z0-9._-]+", "_", (name or "").strip())
    return x.strip("._-") or "codex_session"

# -------------------------
# UI
# -------------------------
@app.get("/diag/status")
def diag_status(request: Request):
    token = _auth_token_from_request(request)
    return {
        "ok": True,
        "app": "Codrex Remote UI",
        "version": app.version,
        "started_at_unix": START_TIME,
        "uptime_s": int(max(0, time.time() - START_TIME)),
        "auth_required": CODEX_AUTH_REQUIRED,
        "authenticated": _is_valid_auth_token(token),
        "paths": {
            "root": "/",
            "diag_js": "/diag/js",
            "auth_status": "/auth/status",
        },
        "js_badge_expected": "JS: basic -> JS: ok",
    }

@app.get("/diag/js", response_class=HTMLResponse)
def diag_js():
    """
    Minimal JS sanity-check page for mobile devices.

    Why:
    - Some Android Chrome setups can have per-site JS blocked.
    - Users often don't have devtools, so we need a visible signal.
    """
    html = """
<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Codrex Remote UI - JS Diagnostic</title>
    <style>
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; padding: 16px; }
      .box { border: 1px solid #ddd; border-radius: 10px; padding: 12px 14px; margin: 12px 0; background: #fff; }
      .muted { color: #555; font-size: 13px; }
      code, pre { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
      pre { white-space: pre-wrap; word-break: break-word; }
    </style>
    <noscript>
      <div class="box" style="background:#fee2e2;border-color:#fecaca;color:#7f1d1d;">
        <strong>JavaScript is disabled</strong> (or blocked for this site). Enable it in Chrome to use Auto/controls.
      </div>
    </noscript>
  </head>
  <body>
    <h2>JS Diagnostic</h2>
    <div class="box">
      <div id="badge"><strong>JS:</strong> loading...</div>
      <div class="muted">If this never changes to <code>ok</code>, JS is blocked for this site.</div>
    </div>
    <div class="box">
      <div class="muted">User-Agent:</div>
      <pre id="ua">(not available)</pre>
    </div>
    <div class="box">
      <div class="muted">Next steps (Chrome Android):</div>
      <ol>
        <li>Open the site in Chrome.</li>
        <li>Tap the lock/tune icon → Site settings.</li>
        <li>Set JavaScript to <code>Allowed</code>.</li>
        <li>Reload.</li>
      </ol>
    </div>
    <p><a href="/">Back to controller</a></p>
    <script>
      (function () {
        try {
          var el = document.getElementById('badge');
          if (el) el.textContent = 'JS: ok';
        } catch (e) {}
        try {
          var ua = document.getElementById('ua');
          if (ua) ua.textContent = (navigator && navigator.userAgent) ? navigator.userAgent : '(unknown)';
        } catch (e) {}
      })();
    </script>
  </body>
</html>
    """.strip()
    return HTMLResponse(content=html, headers={"Cache-Control": "no-store"})

@app.get("/", response_class=HTMLResponse)
def index(request: Request):
    root = CODEX_FILE_ROOT
    workdir = CODEX_WORKDIR
    distro = WSL_DISTRO
    desktop_enabled = _desktop_enabled_from_request(request)
    authenticated = _is_valid_auth_token(_auth_token_from_request(request))
    desktop_native_w = 1366
    desktop_native_h = 768
    if os.name == "nt":
        try:
            mon = _desktop_monitor()
            w = int(mon.get("width") or 0)
            h = int(mon.get("height") or 0)
            if w > 0:
                desktop_native_w = w
            if h > 0:
                desktop_native_h = h
        except Exception:
            pass
    desktop_tap_w = max(220, min(420, int(desktop_native_w)))
    # Keep aspect ratio and avoid very short tap maps.
    desktop_tap_h = max(140, int(round((desktop_native_h * desktop_tap_w) / max(1, desktop_native_w))))
    desktop_stream_fps = max(0.5, min(float(DESKTOP_STREAM_FPS_DEFAULT), 8.0))
    desktop_stream_level = _clamp(int(DESKTOP_STREAM_PNG_LEVEL_DEFAULT), 0, 9)
    desktop_stream_url = f"/desktop/stream?fps={desktop_stream_fps:g}&level={desktop_stream_level}"
    desktop_live_badge = f"Live stream: {desktop_stream_fps:g} fps"
    desktop_mode_class = "desktop-on" if desktop_enabled else "desktop-off"
    desktop_stream_active = desktop_enabled and (not CODEX_AUTH_REQUIRED or authenticated)
    desktop_stream_src = desktop_stream_url if desktop_stream_active else BLANK_IMAGE_DATA_URL
    desktop_mode_badge_class = "badge running" if desktop_enabled else "badge warn"
    if desktop_stream_active:
        desktop_mode_badge = desktop_live_badge
    elif desktop_enabled and CODEX_AUTH_REQUIRED and not authenticated:
        desktop_mode_badge = "Login required for desktop stream"
    else:
        desktop_mode_badge = "Desktop stream paused"
    desktop_toggle_label = "Off" if desktop_enabled else "On"
    compact_mode = _compact_enabled_from_request(request)
    compact_mode_class = "compact-mode" if compact_mode else "full-mode"
    compact_toggle_href = "/" if compact_mode else "/mobile"
    compact_toggle_label = "Open Full" if compact_mode else "Open Compact"
    compact_pill = "Compact layout" if compact_mode else "Full layout"
    html = """
<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Codrex Master Controller</title>
  <noscript>
    <style>
      .nojs-banner {
        margin: 0;
        padding: 12px 14px;
        background: #fee2e2;
        border-bottom: 1px solid #fecaca;
        color: #7f1d1d;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        font-size: 13px;
      }
      .nojs-banner code { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    </style>
    <div class="nojs-banner">
      JavaScript is disabled or blocked. Turn it on to use this controller UI.
      If JS stays at <code>JS: basic</code>, use <code>Fallback Controls (No-JS)</code> and <code>Fallback Login (No-JS)</code> below.
    </div>
  </noscript>
  <style>
    :root {
      --bg: radial-gradient(1200px 680px at 0% -10%, #e3edf8 0%, #f2f6fb 42%, #eef2f6 100%);
      --panel: #ffffff;
      --text: #111827;
      --muted: #5b6473;
      --border: #d7dfeb;
      --accent: #115e59;
      --accent-strong: #0f766e;
      --accent-soft: #d7f1ee;
      --surface-soft: #f6f9fc;
      --ok: #166534;
      --warn: #9a3412;
      --off: #92400e;
      --radius-sm: 10px;
      --radius-md: 14px;
      --radius-lg: 18px;
      --shadow-sm: 0 8px 24px rgba(15, 23, 42, 0.08);
      --shadow-md: 0 18px 36px rgba(15, 23, 42, 0.12);
      --shadow-focus: 0 0 0 3px rgba(29, 78, 216, 0.18);
      --space-1: 4px;
      --space-2: 8px;
      --space-3: 12px;
      --space-4: 16px;
      --space-5: 24px;
      --space-6: 32px;
    }
    html { scroll-behavior: smooth; }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: "Space Grotesk", "IBM Plex Sans", "Segoe UI", sans-serif;
      min-height: 100vh;
      line-height: 1.35;
    }
    a { color: inherit; }
    h1 { font-size: 28px; margin: 0 0 var(--space-2); letter-spacing: -0.02em; }
    h2 { font-size: 18px; margin: 0; }
    p { margin: 0; }
    .page { max-width: none; width: 100%; margin: 0 auto; padding: var(--space-6) var(--space-5); }
    .top {
      position: sticky;
      top: 0;
      z-index: 25;
      background: linear-gradient(180deg, rgba(244, 249, 255, 0.96), rgba(244, 249, 255, 0.86));
      backdrop-filter: blur(8px);
      border: 1px solid rgba(223, 228, 234, 0.9);
      border-radius: var(--radius-md);
      padding: var(--space-3);
      box-shadow: var(--shadow-sm);
    }
    .quick-nav {
      position: sticky;
      top: 92px;
      z-index: 24;
      display: flex;
      gap: var(--space-2);
      overflow-x: auto;
      padding: 6px;
      border-radius: 999px;
      border: 1px solid #d9e4f1;
      background: rgba(255, 255, 255, 0.84);
      backdrop-filter: blur(10px);
      scrollbar-width: thin;
    }
    .quick-chip {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      white-space: nowrap;
      padding: 8px 12px;
      border-radius: 999px;
      border: 1px solid #cfdae8;
      background: #ffffff;
      color: #1f2937;
      font-size: 13px;
      font-weight: 600;
      text-decoration: none;
      transition: background 140ms ease, transform 140ms ease, border-color 140ms ease;
    }
    .quick-chip:hover {
      background: #f3f8ff;
      border-color: #9ec5ed;
      transform: translateY(-1px);
    }
    .quick-chip:focus-visible {
      outline: none;
      box-shadow: var(--shadow-focus);
    }
    .stack { display: flex; flex-direction: column; gap: var(--space-3); }
    .row { display: flex; gap: var(--space-2); flex-wrap: wrap; align-items: center; }
    .row.tight { gap: var(--space-1); }
    .pair-actions {
      display: grid;
      grid-template-columns: 1fr auto auto auto;
      align-items: end;
    }
    .pair-actions .field {
      min-width: 0;
    }
    .grid { display: grid; grid-template-columns: 1fr; gap: var(--space-4); }
    .span-2 { grid-column: span 1; }
    .card {
      background: var(--panel);
      border: 1px solid rgba(223, 228, 234, 0.92);
      border-radius: var(--radius-md);
      padding: var(--space-4);
      box-shadow: var(--shadow-sm);
      backdrop-filter: blur(2px);
      transition: box-shadow 180ms ease, transform 180ms ease, border-color 180ms ease;
      animation: card-rise 260ms ease both;
      transform-origin: center top;
    }
    .card:hover {
      box-shadow: var(--shadow-md);
      border-color: #c9d9ea;
      transform: translateY(-1px);
    }
    .card.pair-tone { border-top: 4px solid #0f766e; }
    .card.codex-tone { border-top: 4px solid #1d4ed8; }
    .card.tmux-tone { border-top: 4px solid #334155; }
    .card.desktop-tone { border-top: 4px solid #166534; }
    .card.exec-tone { border-top: 4px solid #0e7490; }
    .card.files-tone { border-top: 4px solid #0f766e; }
    .card.shot-tone { border-top: 4px solid #9a3412; }
    .grid > .card:nth-child(2) { animation-delay: 30ms; }
    .grid > .card:nth-child(3) { animation-delay: 60ms; }
    .grid > .card:nth-child(4) { animation-delay: 90ms; }
    .grid > .card:nth-child(5) { animation-delay: 120ms; }
    .grid > .card:nth-child(6) { animation-delay: 150ms; }
    .grid > .card:nth-child(7) { animation-delay: 180ms; }
    @keyframes card-rise {
      from { opacity: 0; transform: translateY(8px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .card-head { display: flex; justify-content: space-between; align-items: center; gap: var(--space-3); }
    .pill {
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 12px;
      background: #eef1f6;
      border: 1px solid var(--border);
      color: #2d3748;
    }
    .pill.brand { background: var(--accent-soft); color: #0f4b47; border-color: #9ad6d1; }
    .muted { color: var(--muted); }
    .small { font-size: 12px; color: var(--muted); }
    .label { font-size: 11px; color: var(--muted); text-transform: uppercase; letter-spacing: 0.04em; }
    .field { display: flex; flex-direction: column; gap: 6px; min-width: 180px; }
    .field.grow { flex: 1 1 280px; }
    .legacy-form { display: flex; flex-wrap: wrap; gap: var(--space-2); align-items: flex-end; }
    .legacy-form .field { flex: 1 1 220px; }
    input, select, textarea {
      width: 100%;
      border: 1px solid var(--border);
      background: #fff;
      padding: 10px 12px;
      border-radius: var(--radius-sm);
      font: inherit;
      color: var(--text);
    }
    input[type="file"] { padding: 7px 10px; background: #fff; }
    textarea { min-height: 90px; resize: vertical; }
    button {
      border-radius: var(--radius-sm);
      border: 1px solid var(--border);
      background: #fff;
      color: var(--text);
      padding: 10px 14px;
      font: inherit;
      font-weight: 600;
      cursor: pointer;
      transition: background 140ms ease, border-color 140ms ease, transform 140ms ease, box-shadow 140ms ease;
    }
    button.primary { background: var(--accent); border-color: var(--accent); color: #fff; }
    button.ghost { background: transparent; }
    button.toggle-btn { min-width: 136px; }
    button.state-on {
      background: var(--ok);
      border-color: var(--ok);
      color: #fff;
    }
    button.state-off {
      background: #fff7ed;
      border-color: #fdba74;
      color: var(--off);
    }
    button.soft {
      background: var(--surface-soft);
      border-color: #cad6e5;
    }
    button.danger { background: #b91c1c; border-color: #b91c1c; color: #fff; }
    button:disabled { opacity: 0.6; cursor: not-allowed; }
    button:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 8px 16px rgba(15, 23, 42, 0.1);
    }
    input:focus-visible, select:focus-visible, textarea:focus-visible, button:focus-visible {
      outline: none;
      box-shadow: var(--shadow-focus);
      border-color: #3b82f6;
    }
    a.ghost {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: var(--radius-sm);
      border: 1px solid var(--border);
      background: transparent;
      color: var(--text);
      padding: 10px 14px;
      font: inherit;
      font-weight: 600;
      cursor: pointer;
      transition: background 140ms ease, border-color 140ms ease, transform 140ms ease, box-shadow 140ms ease;
      text-decoration: none;
    }
    a.ghost:hover {
      transform: translateY(-1px);
      background: #f6f9fc;
      border-color: #c5d4e6;
      box-shadow: 0 8px 16px rgba(15, 23, 42, 0.08);
    }
    a.ghost:focus-visible {
      outline: none;
      box-shadow: var(--shadow-focus);
    }
    .console {
      white-space: pre-wrap;
      background: #0b0d12;
      color: #e5e7eb;
      padding: var(--space-3);
      border-radius: var(--radius-sm);
      min-height: 220px;
      max-height: 520px;
      overflow: auto;
      border: 1px solid #1f2937;
      font-family: "JetBrains Mono", "SFMono-Regular", Menlo, Consolas, monospace;
    }
    #out, #execOut, #codexSessionOut { min-height: 180px; }
    #shotImg { width: 100%; border-radius: var(--radius-md); border: 1px solid var(--border); display: none; }
	    #deskImg {
	      width: 100%;
	      border-radius: var(--radius-sm);
	      border: 1px solid var(--border);
	      touch-action: none;
	      background: #111827;
	      min-height: 240px;
	    }
      .desktop-js-pane { display: none; }
      .desktop-fallback-pane { display: block; }
      html.js-ok-mode .desktop-js-pane { display: block; }
      html.js-ok-mode .desktop-fallback-pane { display: none; }
      .desktop-on .desktop-off-only { display: none; }
      .desktop-off .desktop-live-only { display: none; }
    .desktop-mode-btn-active {
      background: #14532d;
      border-color: #14532d;
      color: #ffffff;
    }
    .desktop-quick-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: var(--space-2);
    }
    .desktop-quick-grid button {
      min-height: 44px;
      border-radius: 12px;
    }
    #desktopJsControls button:nth-child(1),
    #desktopJsControls button:nth-child(2),
    #desktopJsControls button:nth-child(3) {
      background: #f8fafc;
    }
    #desktopJsControls button:nth-child(4),
    #desktopJsControls button:nth-child(5) {
      background: #f3f6fb;
    }
	    .legacy-stream-wrap {
	      overflow: auto;
	      border: 1px solid var(--border);
	      border-radius: var(--radius-sm);
	      background: #0b0d12;
	      max-height: 58vh;
	    }
	    .legacy-stream-tap {
	      display: block;
	      width: __DESKTOP_TAP_W__px;
	      height: __DESKTOP_TAP_H__px;
	      max-width: none;
	      border: 0;
	      cursor: crosshair;
	    }
	    #pairQrImg {
	      width: 220px;
	      max-width: 60vw;
	      background: #ffffff;
	      border-radius: var(--radius-sm);
	      border: 1px solid var(--border);
	      padding: var(--space-2);
	      display: none;
	    }
	    #pairLink {
	      min-height: 0;
	      padding: 10px 12px;
	      background: #0b0d12;
	      color: #e5e7eb;
	      border: 1px solid #1f2937;
	      border-radius: var(--radius-sm);
	      word-break: break-all;
	    }
	    .mono { font-family: "JetBrains Mono", "SFMono-Regular", Menlo, Consolas, monospace; }
	    .badge { padding: 6px 10px; border-radius: 999px; font-size: 12px; border: 1px solid var(--border); background: #f6f6f6; }
	    .badge.ok { background: #e7f7ed; border-color: #b9e5c7; color: #166534; }
	    .badge.warn { background: #fff7ed; border-color: #fed7aa; color: #9a3412; }
	    .badge.err { background: #fee2e2; border-color: #fecaca; color: #b91c1c; }
    .badge.running { background: #e0f2fe; border-color: #bae6fd; color: #075985; }
    .badge.route-ts { background: #dcfce7; border-color: #86efac; color: #166534; }
    .badge.route-lan { background: #e0f2fe; border-color: #93c5fd; color: #1d4ed8; }
    .badge.route-local { background: #fef9c3; border-color: #fde047; color: #92400e; }
    .badge.route-unknown { background: #f3f4f6; border-color: #d1d5db; color: #374151; }
    .pair-diag {
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      background: var(--surface-soft);
      padding: 10px 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .pair-net-grid {
      display: grid;
      gap: 8px;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
    }
    .pair-net-item {
      display: flex;
      flex-direction: column;
      gap: 4px;
      padding: 8px;
      border-radius: 10px;
      border: 1px solid #d6deea;
      background: #fff;
    }
    .pair-net-item .mono {
      font-size: 13px;
      min-height: 16px;
    }
    .pair-safety-ok { color: var(--ok); }
    .pair-safety-warn { color: var(--warn); }
    .panel-title {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: var(--space-3);
    }
    .auth-gate {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.66);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: var(--space-5);
      z-index: 2000;
    }
    .auth-card {
      width: min(460px, 100%);
      background: #ffffff;
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      box-shadow: 0 20px 35px rgba(0, 0, 0, 0.2);
      padding: var(--space-5);
      display: flex;
      flex-direction: column;
      gap: var(--space-3);
    }
    .hidden { display: none !important; }
    body.compact-mode .page {
      max-width: 980px;
      padding: var(--space-4);
    }
    body.compact-mode .top {
      position: static;
    }
    body.compact-mode .quick-nav {
      top: 8px;
    }
    body.compact-mode .grid {
      grid-template-columns: 1fr;
      gap: var(--space-3);
    }
    body.compact-mode .span-2 {
      grid-column: span 1;
    }
    body.compact-mode .legacy-form,
    body.compact-mode [data-testid="legacy-auth-controls"],
    body.compact-mode [data-testid="legacy-codex-controls"],
    body.compact-mode [data-testid="legacy-desktop-controls"],
    body.compact-mode .desktop-fallback-pane {
      display: none !important;
    }
    body.compact-mode .compact-hide {
      display: none !important;
    }
    body.compact-mode .pair-actions {
      grid-template-columns: 1fr 1fr;
    }
    body.compact-mode .pair-actions .field.grow {
      grid-column: 1 / -1;
    }
    body.compact-mode .pair-actions button {
      width: 100%;
    }
    body.compact-mode .console {
      max-height: 320px;
      min-height: 160px;
    }
    @media (max-width: 960px) {
      .span-2 { grid-column: span 1; }
      .page { padding: var(--space-5) var(--space-4); }
      .card { padding: var(--space-3); }
      button, a.ghost { min-height: 44px; }
      .top { position: static; }
      .quick-nav { top: 8px; }
    }
    @media (max-width: 640px) {
      h1 { font-size: 22px; }
      h2 { font-size: 16px; }
      .grid { grid-template-columns: 1fr; gap: var(--space-3); }
      .row { gap: 6px; }
      .quick-chip { font-size: 12px; padding: 7px 11px; }
      .pair-actions {
        grid-template-columns: 1fr 1fr;
      }
      .pair-actions .field.grow {
        grid-column: 1 / -1;
      }
      .pair-actions button {
        width: 100%;
      }
      .pill { font-size: 11px; }
      .field { min-width: 140px; }
      .desktop-quick-grid { grid-template-columns: repeat(2, minmax(0, 1fr)); }
      .desktop-quick-grid button { padding: 10px; font-size: 14px; }
      #deskImg { min-height: 190px; }
    }
  </style>
</head>
<body class="__DESKTOP_MODE_CLASS__ __COMPACT_MODE_CLASS__">
  <div id="authGate" class="auth-gate hidden">
    <div class="auth-card" role="dialog" aria-labelledby="authTitle" aria-modal="true">
      <h2 id="authTitle">Login Required</h2>
      <p class="small">Enter `CODEX_AUTH_TOKEN` to unlock controller access.</p>
      <label class="field">
        <span class="label">Access token</span>
        <input id="authTokenInput" type="password" autocomplete="current-password" data-testid="auth-token-input" />
      </label>
      <div class="row">
        <button id="authLoginBtn" class="primary" onclick="loginAuth()" data-testid="auth-login-btn">Unlock</button>
        <span id="authMsg" class="small"></span>
      </div>
    </div>
  </div>

  <div class="page stack">
    <header class="top stack">
      <div class="row" style="justify-content: space-between; align-items: flex-end;">
        <div class="stack">
          <span class="pill brand">Codrex Master Controller</span>
          <h1>Mobile Control For Codrex + Desktop</h1>
          <p class="muted">Two control panes: Codrex orchestration and desktop remote actions.</p>
        </div>
        <div class="row tight">
          <span id="jsBadge" class="badge">JS: loading…</span>
          <a class="ghost" href="/diag/js" target="_blank" rel="noopener" style="text-decoration:none;">JS diag</a>
          <a class="ghost" href="__COMPACT_TOGGLE_HREF__" data-testid="layout-toggle" style="text-decoration:none;">__COMPACT_TOGGLE_LABEL__</a>
          <span class="pill">layout: <span class="mono">__COMPACT_PILL__</span></span>
          <span class="pill compact-hide">WSL: <span class="mono">__CODEX_DISTRO__</span></span>
          <span class="pill compact-hide">workdir: <span class="mono">__CODEX_WORKDIR__</span></span>
          <span class="pill compact-hide">file root: <span class="mono">__CODEX_ROOT__</span></span>
          <button class="ghost" onclick="logoutAuth()">Logout</button>
        </div>
      </div>
    </header>

    <nav class="quick-nav" aria-label="Section shortcuts" data-testid="quick-nav">
      <a class="quick-chip" href="#pairSection">Pair</a>
      <a class="quick-chip" href="#codexSection">Codrex</a>
      <a class="quick-chip" href="#tmuxSection">Tmux</a>
      <a class="quick-chip" href="#desktopSection">Desktop</a>
      <a class="quick-chip" href="#execSection">Exec</a>
      <a class="quick-chip" href="#filesSection">Files</a>
      <a class="quick-chip" href="#shotSection">Capture</a>
    </nav>

	    <div class="grid">
	      <section id="pairSection" class="card span-2 stack pair-tone" data-testid="pair-card">
	        <div class="card-head">
	          <div class="stack">
	            <h2>Pair Phone (QR)</h2>
	            <p class="small">Generate a short-lived QR code to log your phone in without typing the token.</p>
	          </div>
	          <span class="badge">TTL: <span class="mono">~90s</span></span>
	        </div>

	        <div class="row pair-actions">
	          <label class="field grow">
	            <span class="label">Base URL (must be reachable from phone)</span>
	            <input id="pairBaseUrl" placeholder="http://100.x.x.x:8787" data-testid="pair-base-url" />
	          </label>
	          <button class="ghost soft" onclick="useTailscaleBase()" data-testid="pair-use-tailscale">Use Tailscale</button>
	          <button class="ghost soft" onclick="useLanBase()" data-testid="pair-use-lan">Use LAN</button>
	          <button class="primary" onclick="generatePairQr()" data-testid="pair-generate">Generate QR</button>
	        </div>

          <div class="pair-diag" data-testid="pair-diag">
            <div class="row tight">
              <span class="label">Current route</span>
              <span id="pairRouteBadge" class="badge route-unknown" data-testid="pair-route-badge">Unknown</span>
              <span id="pairSafetyStatus" class="small"></span>
            </div>
            <div class="pair-net-grid">
              <div class="pair-net-item">
                <span class="label">LAN address</span>
                <span id="pairLanIp" class="mono">--</span>
              </div>
              <div class="pair-net-item">
                <span class="label">Tailscale address</span>
                <span id="pairTailscaleIp" class="mono">--</span>
              </div>
            </div>
            <div class="row">
              <button id="pairTailscaleOnlyBtn" class="toggle-btn state-off" onclick="toggleTailscaleOnly()" data-testid="pair-ts-only-btn">Tailscale-only: Off</button>
              <span class="small muted">When ON, QR generation is blocked unless the base URL is Tailscale.</span>
            </div>
          </div>

	        <div class="row" style="align-items: flex-start;">
	          <img id="pairQrImg" alt="Pairing QR code" />
	          <div class="stack grow">
	            <div class="small muted">Scan with your phone camera. Expires in <span id="pairExpires">--</span>s.</div>
	            <div id="pairLink" class="mono small" data-testid="pair-link">No pairing link generated yet.</div>
	            <div id="pairStatus" class="small" data-testid="pair-status"></div>
	          </div>
	        </div>
	      </section>

      <section class="card span-2 stack" data-testid="legacy-auth-controls">
        <div class="card-head">
          <div class="stack">
            <h2>Fallback Login (No-JS)</h2>
            <p class="small">Use this when JS stays at <span class="mono">JS: basic</span> and the Unlock button does not respond.</p>
          </div>
        </div>
        <form class="legacy-form" method="post" action="/legacy/auth/login">
          <label class="field grow">
            <span class="label">Access token</span>
            <input name="token" type="password" autocomplete="current-password" placeholder="Enter CODEX_AUTH_TOKEN" />
          </label>
          <input type="hidden" name="next" value="/" />
          <button class="primary" type="submit">Login (No-JS)</button>
        </form>
        <form class="legacy-form" method="post" action="/legacy/auth/logout">
          <input type="hidden" name="next" value="/" />
          <button class="ghost" type="submit">Logout (No-JS)</button>
          <a class="ghost" href="/auth/status" target="_blank" rel="noopener">Auth status JSON</a>
        </form>
      </section>

	      <section id="codexSection" class="card span-2 stack codex-tone">
	        <div class="panel-title">
	          <h2>Codrex Sessions (Master Pane)</h2>
	          <span id="codexSessionBadge" class="badge">loading…</span>
	        </div>
        <p class="small">Create multiple sessions, watch progress, send prompts, and attach images.</p>

        <div class="row">
          <label class="field">
            <span class="label">Session Name</span>
            <input id="codexSessionName" placeholder="e.g. feature_api_docs" data-testid="codex-session-name" />
          </label>
          <label class="field grow">
            <span class="label">Session CWD (optional)</span>
            <input id="codexSessionCwd" placeholder="Defaults to __CODEX_WORKDIR__" data-testid="codex-session-cwd" />
          </label>
          <button class="primary" onclick="createCodexSession()" data-testid="codex-session-create">Create Codex Session</button>
          <button onclick="refreshCodexSessions()">Refresh</button>
        </div>

        <div class="row">
          <label class="field grow">
            <span class="label">Active Session</span>
            <select id="codexSessionSelect" data-testid="codex-session-select"></select>
          </label>
          <button class="danger" onclick="closeCodexSession()">Close Session</button>
          <button class="ghost" onclick="loadCodexSessionScreen()">View Output</button>
          <button id="codexStreamBtn" class="toggle-btn state-on" onclick="toggleCodexStream()" data-testid="codex-stream-btn">Stream: On</button>
          <label class="field" style="min-width: 160px;">
            <span class="label">Live rate</span>
            <select id="codexStreamRate" data-testid="codex-stream-rate">
              <option value="300">Very fast</option>
              <option value="600">Fast</option>
              <option value="900" selected>Normal</option>
              <option value="1500">Slow</option>
              <option value="2500">Very slow</option>
            </select>
          </label>
          <span id="codexStreamStatus" class="small"></span>
          <span id="codexSessionState" class="small"></span>
        </div>

	        <div class="row">
	          <label class="field grow">
	            <span class="label">Prompt</span>
	            <input id="codexSessionPrompt" placeholder="Send command or prompt to selected session..." data-testid="codex-session-prompt" />
	          </label>
	          <button class="primary" onclick="sendCodexSessionPrompt()">Send</button>
	          <button onclick="sendCtrlCToSession()">Interrupt (Esc)</button>
	        </div>

        <div class="row">
          <input id="codexSessionImage" type="file" accept="image/*" data-testid="codex-session-image" />
          <label class="field grow">
            <span class="label">Image Message</span>
            <input id="codexSessionImagePrompt" placeholder="Optional instruction for this image..." data-testid="codex-session-image-prompt" />
          </label>
          <button onclick="uploadCodexSessionImage()">Send Image</button>
        </div>

        <div id="codexSessionOut" class="console" data-testid="codex-session-out">Select a session to inspect output.</div>
      </section>

      <section class="card span-2 stack" data-testid="legacy-codex-controls">
        <div class="card-head">
          <div class="stack">
            <h2>Fallback Controls (No-JS)</h2>
            <p class="small">If JS badge is not <span class="mono">JS: ok</span>, use these forms to control Codrex sessions.</p>
          </div>
        </div>

        <form class="legacy-form" method="post" action="/legacy/codex/create">
          <label class="field">
            <span class="label">Create Session Name</span>
            <input name="name" placeholder="e.g. codex_mobile" />
          </label>
          <label class="field grow">
            <span class="label">Create CWD (optional)</span>
            <input name="cwd" placeholder="Defaults to __CODEX_WORKDIR__" />
          </label>
          <button class="primary" type="submit">Create</button>
        </form>

        <form class="legacy-form" method="post" action="/legacy/codex/send">
          <label class="field">
            <span class="label">Send Session</span>
            <input name="session" placeholder="codex_xxxxxxxx" required />
          </label>
          <label class="field grow">
            <span class="label">Prompt</span>
            <input name="text" placeholder="Type prompt to send..." required />
          </label>
          <button class="primary" type="submit">Send Prompt</button>
        </form>

        <div class="row">
          <form class="legacy-form" method="post" action="/legacy/codex/interrupt">
            <label class="field">
              <span class="label">Interrupt Session</span>
              <input name="session" placeholder="codex_xxxxxxxx" required />
            </label>
            <button class="ghost" type="submit">Interrupt (Esc)</button>
          </form>

          <form class="legacy-form" method="post" action="/legacy/codex/close">
            <label class="field">
              <span class="label">Close Session</span>
              <input name="session" placeholder="codex_xxxxxxxx" required />
            </label>
            <button class="danger" type="submit">Close</button>
          </form>
        </div>

        <form class="legacy-form" method="get" action="/legacy/codex/screen">
          <label class="field">
            <span class="label">View Session Screen</span>
            <input name="session" placeholder="codex_xxxxxxxx" required />
          </label>
          <button type="submit">Open Screen</button>
          <a class="ghost" href="/codex/sessions" target="_blank" rel="noopener">Sessions JSON</a>
        </form>
      </section>

      <section id="tmuxSection" class="card span-2 stack tmux-tone">
        <div class="card-head">
          <div class="stack">
            <h2>Tmux sessions</h2>
            <p class="small">Create, view, and control tmux panes inside WSL.</p>
          </div>
          <span id="tmuxBadge" class="badge">tmux: checking…</span>
        </div>

        <div class="row">
          <button onclick="refreshPanes()">Refresh panes</button>
          <button class="ghost" onclick="debugTmux()">Debug tmux</button>
          <button id="tmuxStreamBtn" class="toggle-btn state-on" onclick="toggleTmuxStream()" data-testid="tmux-stream-btn">Stream: On</button>
          <label class="field" style="min-width: 160px;">
            <span class="label">Live rate</span>
            <select id="tmuxStreamRate" data-testid="tmux-stream-rate">
              <option value="300">Very fast</option>
              <option value="600">Fast</option>
              <option value="900" selected>Normal</option>
              <option value="1500">Slow</option>
              <option value="2500">Very slow</option>
            </select>
          </label>
          <span id="tmuxStreamStatus" class="small"></span>
          <span class="small" id="status"></span>
        </div>

        <div class="row">
          <label class="field">
            <span class="label">New session</span>
            <input id="sessionName" placeholder="Optional name (letters, numbers, ._-)" />
          </label>
          <button class="primary" onclick="createSession()">Create session</button>
          <label class="field">
            <span class="label">Close session</span>
            <select id="sessionSelect"></select>
          </label>
          <button id="closeSessionBtn" class="danger" onclick="closeSession()">Close</button>
        </div>

	        <div class="row">
	          <label class="field">
	            <span class="label">Pane</span>
	            <select id="pane"></select>
	          </label>
	          <button onclick="fetchScreen()">View</button>
	          <button class="ghost" onclick="ctrlC()">Interrupt</button>
	        </div>

        <div id="out" class="console" data-testid="tmux-out">Loading…</div>

        <div class="row">
          <label class="field grow">
            <span class="label">Send to pane</span>
            <input id="msg" placeholder="Send to selected pane (Codrex TUI or shell)..." />
          </label>
          <button class="primary" onclick="sendMsg()">Send</button>
        </div>
      </section>

      <section id="desktopSection" class="card stack desktop-tone">
        <div class="card-head">
          <div class="stack">
            <h2>Desktop Remote (Control Pane)</h2>
            <p class="small">Live screenshot stream + input controls for mobile/tablet remote actions.</p>
          </div>
          <div class="row tight">
            <span id="desktopModeBadge" class="__DESKTOP_MODE_BADGE_CLASS__" data-testid="desktop-stream-mode">__DESKTOP_MODE_BADGE__</span>
            <button id="desktopModeBtn" class="toggle-btn" onclick="toggleDesktopMode()" data-testid="desktop-mode-btn">Control: __DESKTOP_TOGGLE_LABEL__</button>
          </div>
        </div>
        <div class="stack desktop-js-pane">
          <div class="desktop-live-only">
            <img id="deskImg" alt="Desktop remote stream" src="__DESKTOP_STREAM_SRC__" data-testid="desktop-image" />
            <div class="row tight">
              <a id="deskStreamLink" class="ghost" href="__DESKTOP_STREAM_URL__" target="_blank" rel="noopener">Open live stream</a>
              <label class="field" style="min-width: 170px;">
                <span class="label">Stream profile</span>
                <select id="deskPerf" data-testid="desktop-stream-profile">
                  <option value="balanced" selected>Balanced</option>
                  <option value="responsive">Responsive</option>
                  <option value="saver">Data Saver</option>
                </select>
              </label>
              <a class="ghost" href="/auth/status" target="_blank" rel="noopener">Auth status</a>
            </div>
            <div class="desktop-quick-grid" id="desktopJsControls">
              <button onclick="desktopClick('left')">Left Click</button>
              <button onclick="desktopClick('right')">Right Click</button>
              <button onclick="desktopClick('left', true)">Double Click</button>
              <button onclick="desktopScroll(-240)">Scroll Up</button>
              <button onclick="desktopScroll(240)">Scroll Down</button>
            </div>
    	        <div class="row">
    	          <label class="field grow">
    	            <span class="label">Live Keyboard (real time)</span>
    	            <input id="deskLiveInput" placeholder="Type here to control the desktop. Backspace works." data-testid="desktop-live-input" autocomplete="off" autocapitalize="off" spellcheck="false" />
    	          </label>
    	          <button class="ghost" onclick="pasteToLive()" data-testid="desktop-live-paste">Paste</button>
    	          <button class="ghost" onclick="resetLiveBuffer()" data-testid="desktop-live-reset">Reset</button>
    	        </div>
    	        <p class="small muted">This box mirrors what you type on mobile. It may not reflect existing desktop text.</p>
    	        <div class="row">
    	          <label class="field">
    	            <span class="label">Key</span>
    	            <select id="deskKey" data-testid="desktop-key-select">
    	              <option value="enter">Enter</option>
    	              <option value="backspace">Backspace</option>
    	              <option value="delete">Delete</option>
    	              <option value="esc">Esc</option>
    	              <option value="tab">Tab</option>
    	              <option value="up">Up</option>
    	              <option value="down">Down</option>
    	              <option value="left">Left</option>
    	              <option value="right">Right</option>
    	              <option value="alt+tab">Alt+Tab</option>
    	              <option value="ctrl+a">Ctrl+A</option>
    	              <option value="ctrl+c">Ctrl+C</option>
    	            </select>
    	          </label>
    	          <button onclick="desktopSendKey()">Send Key</button>
    	          <span id="deskStatus" class="small"></span>
    	        </div>
          </div>
          <div class="desktop-off-only small muted">Desktop stream/control is off. Turn it on when you need to interact.</div>
        </div>

        <div class="stack desktop-fallback-pane" data-testid="legacy-desktop-controls">
          <div class="row">
            <form class="legacy-form" method="post" action="/legacy/desktop/mode">
              <input type="hidden" name="enabled" value="1" />
              <input type="hidden" name="next" value="/" />
              <button class="primary" type="submit">Desktop On</button>
            </form>
            <form class="legacy-form" method="post" action="/legacy/desktop/mode">
              <input type="hidden" name="enabled" value="0" />
              <input type="hidden" name="next" value="/" />
              <button class="ghost" type="submit">Desktop Off</button>
            </form>
          </div>
          <div class="small">Fallback Controls (No-JS): use these when JS stays at <span class="mono">JS: basic</span>.</div>

          <div class="row desktop-live-only">
            <form class="legacy-form" method="post" action="/legacy/desktop/click" target="legacyDesktopResult">
              <input type="hidden" name="button" value="left" />
              <button type="submit">Left Click (cursor)</button>
            </form>
            <form class="legacy-form" method="post" action="/legacy/desktop/click" target="legacyDesktopResult">
              <input type="hidden" name="button" value="right" />
              <button type="submit">Right Click (cursor)</button>
            </form>
            <form class="legacy-form" method="post" action="/legacy/desktop/click" target="legacyDesktopResult">
              <input type="hidden" name="button" value="left" />
              <input type="hidden" name="double" value="1" />
              <button type="submit">Double Click (cursor)</button>
            </form>
            <form class="legacy-form" method="post" action="/legacy/desktop/scroll" target="legacyDesktopResult">
              <input type="hidden" name="delta" value="-240" />
              <button type="submit">Scroll Up</button>
            </form>
            <form class="legacy-form" method="post" action="/legacy/desktop/scroll" target="legacyDesktopResult">
              <input type="hidden" name="delta" value="240" />
              <button type="submit">Scroll Down</button>
            </form>
          </div>

          <form class="legacy-form desktop-live-only" method="post" action="/legacy/desktop/key" target="legacyDesktopResult">
            <label class="field">
              <span class="label">Key (No-JS)</span>
              <select name="key">
                <option value="enter">Enter</option>
                <option value="backspace">Backspace</option>
                <option value="delete">Delete</option>
                <option value="esc">Esc</option>
                <option value="tab">Tab</option>
                <option value="up">Up</option>
                <option value="down">Down</option>
                <option value="left">Left</option>
                <option value="right">Right</option>
                <option value="alt+tab">Alt+Tab</option>
                <option value="ctrl+a">Ctrl+A</option>
                <option value="ctrl+c">Ctrl+C</option>
              </select>
            </label>
            <button type="submit">Send Key</button>
          </form>

          <form class="legacy-form desktop-live-only" method="post" action="/legacy/desktop/text" target="legacyDesktopResult">
            <label class="field grow">
              <span class="label">Type text (No-JS)</span>
              <input name="text" placeholder="Type text to send to Windows desktop..." required />
            </label>
            <button type="submit">Send Text</button>
          </form>

          <div class="small muted desktop-live-only">Tap-to-click map (native desktop size). Pan inside this area, then tap to click that exact point.</div>
          <form class="stack desktop-live-only" method="post" action="/legacy/desktop/tap" target="legacyDesktopResult">
            <input type="hidden" name="button" value="left" />
            <input type="hidden" name="double" value="0" />
            <input type="hidden" name="render_w" value="__DESKTOP_TAP_W__" />
            <input type="hidden" name="render_h" value="__DESKTOP_TAP_H__" />
            <div class="legacy-stream-wrap">
              <input class="legacy-stream-tap" type="image" name="tap" src="__DESKTOP_STREAM_SRC__" alt="Tap this live stream to left-click at that point" width="__DESKTOP_TAP_W__" height="__DESKTOP_TAP_H__" data-testid="legacy-desktop-tap-map" />
            </div>
          </form>
          <div class="desktop-off-only small muted">Desktop stream/control is off. Use Desktop On above to resume.</div>
          <iframe name="legacyDesktopResult" title="Desktop fallback result" style="width:100%; min-height:120px; border:1px solid var(--border); border-radius: var(--radius-sm); background:#fff;"></iframe>
        </div>
      </section>

      <section id="execSection" class="card stack exec-tone">
        <div class="card-head">
          <div class="stack">
            <h2>One-shot: codex exec</h2>
            <p class="small">Runs <span class="mono">codex exec --cd __CODEX_WORKDIR__</span> inside WSL and shows stdout/stderr.</p>
          </div>
          <div class="row">
            <button id="execBtn" class="primary" onclick="runExec()">Run</button>
            <button class="ghost" onclick="loadRuns()">Refresh runs</button>
          </div>
        </div>
        <textarea id="execPrompt" placeholder="Example: Summarize this repo and propose next steps"></textarea>
        <div class="row">
          <span class="small" id="execStatus"></span>
        </div>
        <div id="execOut" class="console mono"></div>
        <div class="small" style="margin-top:8px;">Recent runs:</div>
        <div id="runsList" class="small mono"></div>
      </section>

      <section id="filesSection" class="card stack files-tone">
        <div class="card-head">
          <div class="stack">
            <h2>WSL Files</h2>
            <p class="small">Download and upload files under <span class="mono">__CODEX_ROOT__</span>.</p>
          </div>
        </div>

        <div class="row">
          <label class="field grow">
            <span class="label">Download path</span>
            <input id="dlPath" placeholder="Relative path, e.g. README.md" />
          </label>
          <button onclick="downloadWsl()">Download</button>
        </div>

        <div class="row">
          <label class="field grow">
            <span class="label">Upload destination</span>
            <input id="upDest" placeholder="Relative path (leave blank to use filename)" />
          </label>
          <input id="upFile" type="file" />
          <button class="primary" onclick="uploadWsl()">Upload</button>
          <span class="small" id="fileStatus"></span>
        </div>

        <div class="small mono" id="fileOut"></div>
      </section>

      <section id="shotSection" class="card stack shot-tone">
        <div class="card-head">
          <div class="stack">
            <h2>Screenshot Capture</h2>
            <p class="small">One-tap desktop screenshot capture and share.</p>
          </div>
          <button onclick="takeShot()">Capture</button>
        </div>
        <div class="row tight">
          <a class="ghost" href="/shot" target="_blank" rel="noopener">Open latest capture</a>
        </div>
        <img id="shotImg" alt="Windows screenshot" />
      </section>
    </div>
  </div>

<script>
// Minimal ES5 "JS is enabled" signal that runs even if later scripts fail to parse.
(function () {
  try {
    if (document && document.documentElement && document.documentElement.classList) {
      document.documentElement.classList.add('js-basic-mode');
    }
    var el = document.getElementById('jsBadge');
    if (el) el.textContent = "JS: basic";
  } catch (e) {}
})();
</script>

<script>
// Surface runtime errors in the UI so mobile browsers without devtools aren't a black box.
try {
  window.addEventListener('error', (e) => {
    const msg = (e && e.message) ? String(e.message) : "error";
    const el = document.getElementById('jsBadge');
    if (el) el.textContent = `JS: err`;
    const st = document.getElementById('status');
    if (st && msg) st.textContent = `JS error: ${msg}`.slice(0, 120);
  });
  window.addEventListener('unhandledrejection', (e) => {
    const msg = (e && e.reason) ? String(e.reason) : "promise rejection";
    const el = document.getElementById('jsBadge');
    if (el) el.textContent = `JS: err`;
    const st = document.getElementById('status');
    if (st && msg) st.textContent = `JS rejection: ${msg}`.slice(0, 120);
  });
} catch (_e) {}

const paneSel = document.getElementById('pane');
const sessionSel = document.getElementById('sessionSelect');
const closeSessionBtn = document.getElementById('closeSessionBtn');
const outEl = document.getElementById('out');
const statusEl = document.getElementById('status');
const shotImg = document.getElementById('shotImg');

const execStatusEl = document.getElementById('execStatus');
const execOutEl = document.getElementById('execOut');
const runsListEl = document.getElementById('runsList');
const execBtn = document.getElementById('execBtn');

const fileStatusEl = document.getElementById('fileStatus');
const fileOutEl = document.getElementById('fileOut');
const tmuxBadgeEl = document.getElementById('tmuxBadge');
const tmuxStreamBtnEl = document.getElementById('tmuxStreamBtn');
const tmuxStreamRateEl = document.getElementById('tmuxStreamRate');
const tmuxStreamStatusEl = document.getElementById('tmuxStreamStatus');
const authGateEl = document.getElementById('authGate');
const authMsgEl = document.getElementById('authMsg');
const authTokenInputEl = document.getElementById('authTokenInput');
const codexSessionBadgeEl = document.getElementById('codexSessionBadge');
const codexSessionNameEl = document.getElementById('codexSessionName');
const codexSessionCwdEl = document.getElementById('codexSessionCwd');
const codexSessionSelectEl = document.getElementById('codexSessionSelect');
const codexSessionPromptEl = document.getElementById('codexSessionPrompt');
const codexSessionImageEl = document.getElementById('codexSessionImage');
const codexSessionImagePromptEl = document.getElementById('codexSessionImagePrompt');
const codexSessionOutEl = document.getElementById('codexSessionOut');
const codexSessionStateEl = document.getElementById('codexSessionState');
const codexStreamBtnEl = document.getElementById('codexStreamBtn');
const codexStreamRateEl = document.getElementById('codexStreamRate');
const codexStreamStatusEl = document.getElementById('codexStreamStatus');
		const deskImgEl = document.getElementById('deskImg');
		const deskStatusEl = document.getElementById('deskStatus');
		const deskLiveInputEl = document.getElementById('deskLiveInput');
		const deskKeyEl = document.getElementById('deskKey');
		const deskPerfEl = document.getElementById('deskPerf');
		const deskStreamLinkEl = document.getElementById('deskStreamLink');
		const deskModeBtnEl = document.getElementById('desktopModeBtn');
		const deskModeBadgeEl = document.getElementById('desktopModeBadge');
		const deskRateEl = document.getElementById('deskRate');
		const deskAutoBtnEl = document.getElementById('deskAutoBtn');
	const pairBaseUrlEl = document.getElementById('pairBaseUrl');
	const pairQrImgEl = document.getElementById('pairQrImg');
	const pairLinkEl = document.getElementById('pairLink');
const pairStatusEl = document.getElementById('pairStatus');
const pairExpiresEl = document.getElementById('pairExpires');
const pairRouteBadgeEl = document.getElementById('pairRouteBadge');
const pairLanIpEl = document.getElementById('pairLanIp');
const pairTailscaleIpEl = document.getElementById('pairTailscaleIp');
const pairTailscaleOnlyBtnEl = document.getElementById('pairTailscaleOnlyBtn');
const pairSafetyStatusEl = document.getElementById('pairSafetyStatus');

const paneSessionMap = new Map();
const codexSessionPaneMap = new Map();
let tmuxStream = { enabled: true, es: null, paneId: "", url: "", intervalMs: 900, maxChars: 25000, connected: false };
let codexStream = { enabled: true, es: null, paneId: "", url: "", intervalMs: 900, maxChars: 25000, connected: false };
let desktopInfo = null;
		let desktopModeEnabled = __DESKTOP_MODE_ENABLED__;
		let desktopStreamUrl = "__DESKTOP_STREAM_URL__";
		const desktopBlankImage = "__BLANK_IMAGE_DATA_URL__";
		const desktopLiveBadgeText = "__DESKTOP_LIVE_BADGE__";
		let desktopAutoTimer = null;
		let desktopAutoEnabled = false;
		let desktopAutoMs = 1200;
		let desktopLastFrameMs = 0;
		let desktopFrameInFlight = false;
		let desktopLastReqMs = 0;
		let desktopReqCount = 0;
		let desktopOkCount = 0;
		let desktopErrCount = 0;
		let desktopLastDiagMs = 0;
		let desktopDiagInFlight = false;
		let lastDesktopPoint = null;
		let liveKeyQueue = Promise.resolve();
		let liveLastValue = "";
		let netInfo = null;
		let pairCountdownTimer = null;
		let pairTailscaleOnly = false;
let authState = { auth_required: false, authenticated: false };
let desktopAutoBound = false;

function bindDesktopAutoButton() {
  if (!deskAutoBtnEl || desktopAutoBound) return;
  deskAutoBound = true;
  deskAutoBtnEl.addEventListener('click', (e) => {
    try { e.preventDefault(); } catch (_e) {}
    toggleDesktopAuto();
  });
}

	if (pairBaseUrlEl && !pairBaseUrlEl.value) {
	  pairBaseUrlEl.value = window.location.origin;
	}
if (pairBaseUrlEl) {
  pairBaseUrlEl.addEventListener('input', () => _syncPairRouteUi());
  pairBaseUrlEl.addEventListener('change', () => _syncPairRouteUi());
}

function encPaneId(p) { return encodeURIComponent(p); }

function _isNearBottom(el, thresholdPx = 80) {
  if (!el) return true;
  try {
    const delta = el.scrollHeight - el.scrollTop - el.clientHeight;
    return delta < thresholdPx;
  } catch (_e) {
    return true;
  }
}

function _setConsoleText(el, text) {
  if (!el) return;
  const stick = _isNearBottom(el);
  el.textContent = text || "";
  if (stick) {
    try { el.scrollTop = el.scrollHeight; } catch (_e) {}
  }
}

function _readIntValue(el, fallback) {
  if (!el) return fallback;
  const n = Number(el.value);
  return Number.isFinite(n) ? n : fallback;
}

function _closeEventSource(es) {
  try { if (es) es.close(); } catch (_e) {}
}

function _streamUrlForPane(paneId, intervalMs, maxChars) {
  const qs = new URLSearchParams();
  qs.set("interval_ms", String(intervalMs || 900));
  qs.set("max_chars", String(maxChars || 25000));
  return `/tmux/pane/${encPaneId(paneId)}/stream?${qs.toString()}`;
}

function _syncStreamBtn(btnEl, enabled) {
  if (!btnEl) return;
  btnEl.textContent = enabled ? "Stream: On" : "Stream: Off";
  btnEl.classList.add("toggle-btn");
  btnEl.classList.toggle("state-on", !!enabled);
  btnEl.classList.toggle("state-off", !enabled);
}

function _setStreamStatus(statusEl, text) {
  if (!statusEl) return;
  statusEl.textContent = text || "";
}

function _startPaneStream(streamState, paneId, outTargetEl, statusEl) {
  if (!streamState || !streamState.enabled) return;
  if (!paneId) return;
  const url = _streamUrlForPane(paneId, streamState.intervalMs, streamState.maxChars);
  if (streamState.es && streamState.url === url) return;

  _closeEventSource(streamState.es);
  streamState.es = null;
  streamState.paneId = paneId;
  streamState.url = url;
  streamState.connected = false;

  _setStreamStatus(statusEl, "stream: connecting…");
  const es = new EventSource(url);
  streamState.es = es;

  es.addEventListener("hello", (_ev) => {
    streamState.connected = true;
    _setStreamStatus(statusEl, `stream: on (${streamState.intervalMs}ms)`);
  });

  es.addEventListener("screen", (ev) => {
    let j = null;
    try { j = JSON.parse(ev.data); } catch (_e) { j = null; }
    if (!j || !j.ok) return;
    _setConsoleText(outTargetEl, j.text || "");
  });

  es.addEventListener("error", (_ev) => {
    streamState.connected = false;
    _setStreamStatus(statusEl, "stream: error (fallback: polling)");
    _closeEventSource(es);
    if (streamState.es === es) streamState.es = null;
  });
}

function _stopPaneStream(streamState, statusEl) {
  if (!streamState) return;
  _closeEventSource(streamState.es);
  streamState.es = null;
  streamState.paneId = "";
  streamState.url = "";
  streamState.connected = false;
  _setStreamStatus(statusEl, "stream: off");
}

function toggleTmuxStream() {
  tmuxStream.enabled = !tmuxStream.enabled;
  _syncStreamBtn(tmuxStreamBtnEl, tmuxStream.enabled);
  if (tmuxStream.enabled) {
    tmuxStream.intervalMs = _readIntValue(tmuxStreamRateEl, tmuxStream.intervalMs);
    _startPaneStream(tmuxStream, paneSel.value, outEl, tmuxStreamStatusEl);
  } else {
    _stopPaneStream(tmuxStream, tmuxStreamStatusEl);
  }
}

function toggleCodexStream() {
  codexStream.enabled = !codexStream.enabled;
  _syncStreamBtn(codexStreamBtnEl, codexStream.enabled);
  if (codexStream.enabled) {
    codexStream.intervalMs = _readIntValue(codexStreamRateEl, codexStream.intervalMs);
    const session = codexSessionSelectEl ? codexSessionSelectEl.value : "";
    const paneId = session ? (codexSessionPaneMap.get(session) || "") : "";
    _startPaneStream(codexStream, paneId, codexSessionOutEl, codexStreamStatusEl);
  } else {
    _stopPaneStream(codexStream, codexStreamStatusEl);
  }
}

function setAuthGate(open, message="") {
  authGateEl.classList.toggle('hidden', !open);
  authMsgEl.textContent = message || "";
}

async function apiFetch(url, options = {}) {
  const res = await fetch(url, options);
  if (res.status === 401) {
    setAuthGate(true, "Authentication required.");
    throw new Error("unauthorized");
  }
  return res;
}

async function checkAuthStatus() {
  const r = await fetch('/auth/status');
  const j = await r.json();
  if (!j.ok) return;
  authState = j;
  if (j.auth_required && !j.authenticated) {
    setAuthGate(true, "Enter access token.");
  } else {
    setAuthGate(false);
  }
}

function _hashParams() {
  // Supports pairing links like:
  //   http://host:8787/#pair=...   (hash isn't sent to server)
  // and token links like:
  //   http://host:8787/#token=...
  const raw = (window.location.hash || "").replace(/^#/, "").trim();
  if (!raw) return null;
  try { return new URLSearchParams(raw); } catch (_e) { return null; }
}

function _clearHash() {
  // Removes token from URL bar/history after using it.
  try {
    history.replaceState(null, "", window.location.pathname + window.location.search);
  } catch (_e) {}
}

async function autoLoginFromHash() {
  const params = _hashParams();
  if (!params) return false;
  const token = (params.get("token") || params.get("auth") || "").trim();
  const pair = (params.get("pair") || params.get("code") || "").trim();
  if (!token && !pair) return false;
  authMsgEl.textContent = "Pairing…";
  try {
    const r = await fetch(pair ? '/auth/pair/exchange' : '/auth/login', {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(pair ? { code: pair } : { token })
    });
    const j = await r.json();
    _clearHash();
    if (!j.ok) {
      setAuthGate(true, j.detail || "Login failed.");
      return false;
    }
    setAuthGate(false);
    return true;
  } catch (_e) {
    _clearHash();
    return false;
  }
}

async function loginAuth() {
  const token = (authTokenInputEl.value || "").trim();
  if (!token) {
    setAuthGate(true, "Token is required.");
    return;
  }
  authMsgEl.textContent = "Checking token…";
  try {
    const r = await fetch('/auth/login', {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ token })
    });
    const j = await r.json();
    if (!j.ok) {
      setAuthGate(true, j.detail || "Login failed.");
      return;
    }
    authTokenInputEl.value = "";
    setAuthGate(false);
    await bootstrapAll();
  } catch (_e) {
    setAuthGate(true, "Login request failed.");
  }
}

async function logoutAuth() {
  await fetch('/auth/logout', { method: 'POST' });
  setAuthGate(true, "Logged out.");
}

async function _fetchNetInfo() {
  if (netInfo) return netInfo;
  try {
    const r = await apiFetch('/net/info');
    const j = await r.json();
    if (j && j.ok) {
      netInfo = j;
      _syncPairNetworkUi();
      return netInfo;
    }
  } catch (_e) {
    _syncPairNetworkUi();
  }
  return null;
}

function _normalizeBaseUrl(raw) {
  let base = (raw || "").trim();
  if (!base) return "";
  if (!/^https?:\\/\\//i.test(base)) base = "http://" + base;
  base = base.replace(/\\/+$/, "");
  return base;
}

function _setPairStatus(msg) {
  if (!pairStatusEl) return;
  pairStatusEl.textContent = msg || "";
}

const PAIR_TS_ONLY_KEY = "codex_pair_tailscale_only_v1";

function _storageGetBool(key, fallback = false) {
  try {
    const raw = localStorage.getItem(key);
    if (raw == null) return fallback;
    return String(raw).toLowerCase() === "true";
  } catch (_e) {
    return fallback;
  }
}

function _storageSetBool(key, value) {
  try { localStorage.setItem(key, value ? "true" : "false"); } catch (_e) {}
}

function _baseHost(baseUrl) {
  try {
    const base = _normalizeBaseUrl(baseUrl || "");
    if (!base) return "";
    return (new URL(base)).hostname || "";
  } catch (_e) {
    return "";
  }
}

function _isPrivateIpv4(host) {
  if (!/^\\d+\\.\\d+\\.\\d+\\.\\d+$/.test(host || "")) return false;
  return (
    host.startsWith("10.") ||
    host.startsWith("192.168.") ||
    /^172\\.(1[6-9]|2\\d|3[01])\\./.test(host)
  );
}

function _pairRouteKind(baseUrl, info) {
  const host = _baseHost(baseUrl);
  if (!host) return "unknown";
  if (host === "localhost" || host === "127.0.0.1") return "local";
  const ts = (info && info.tailscale_ip) ? String(info.tailscale_ip) : "";
  const lan = (info && info.lan_ip) ? String(info.lan_ip) : "";
  if (ts && host === ts) return "tailscale";
  if (lan && host === lan) return "lan";
  if (/^100\\./.test(host) || host.endsWith(".ts.net")) return "tailscale";
  if (_isPrivateIpv4(host)) return "lan";
  return "unknown";
}

function _pairRouteLabel(kind) {
  if (kind === "tailscale") return "Tailscale";
  if (kind === "lan") return "LAN";
  if (kind === "local") return "Localhost";
  return "Unknown";
}

function _syncPairRouteUi() {
  const kind = _pairRouteKind(pairBaseUrlEl ? pairBaseUrlEl.value : "", netInfo);
  if (pairRouteBadgeEl) {
    pairRouteBadgeEl.textContent = _pairRouteLabel(kind);
    pairRouteBadgeEl.classList.remove("route-ts", "route-lan", "route-local", "route-unknown");
    if (kind === "tailscale") pairRouteBadgeEl.classList.add("route-ts");
    else if (kind === "lan") pairRouteBadgeEl.classList.add("route-lan");
    else if (kind === "local") pairRouteBadgeEl.classList.add("route-local");
    else pairRouteBadgeEl.classList.add("route-unknown");
  }
  if (pairSafetyStatusEl) {
    pairSafetyStatusEl.classList.remove("pair-safety-ok", "pair-safety-warn");
    if (pairTailscaleOnly && kind !== "tailscale") {
      pairSafetyStatusEl.classList.add("pair-safety-warn");
      pairSafetyStatusEl.textContent = "Tailscale-only is ON. Current base URL is blocked.";
    } else if (kind === "local") {
      pairSafetyStatusEl.classList.add("pair-safety-warn");
      pairSafetyStatusEl.textContent = "Localhost is not reachable from phone. Use LAN or Tailscale.";
    } else if (kind === "unknown") {
      pairSafetyStatusEl.classList.add("pair-safety-warn");
      pairSafetyStatusEl.textContent = "Route not recognized. Verify this URL is reachable from mobile.";
    } else {
      pairSafetyStatusEl.classList.add("pair-safety-ok");
      pairSafetyStatusEl.textContent = "Route looks reachable.";
    }
  }
}

function _syncPairNetworkUi() {
  if (pairLanIpEl) pairLanIpEl.textContent = (netInfo && netInfo.lan_ip) ? netInfo.lan_ip : "--";
  if (pairTailscaleIpEl) pairTailscaleIpEl.textContent = (netInfo && netInfo.tailscale_ip) ? netInfo.tailscale_ip : "--";
  _syncPairRouteUi();
}

function _syncTailscaleOnlyBtn() {
  if (!pairTailscaleOnlyBtnEl) return;
  pairTailscaleOnlyBtnEl.textContent = pairTailscaleOnly ? "Tailscale-only: On" : "Tailscale-only: Off";
  pairTailscaleOnlyBtnEl.classList.toggle("state-on", pairTailscaleOnly);
  pairTailscaleOnlyBtnEl.classList.toggle("state-off", !pairTailscaleOnly);
}

async function toggleTailscaleOnly() {
  pairTailscaleOnly = !pairTailscaleOnly;
  _storageSetBool(PAIR_TS_ONLY_KEY, pairTailscaleOnly);
  _syncTailscaleOnlyBtn();
  _syncPairRouteUi();
  if (pairTailscaleOnly) {
    _setPairStatus("Tailscale-only enabled.");
  } else {
    _setPairStatus("Tailscale-only disabled.");
  }
}

function _startPairCountdown(seconds) {
  if (!pairExpiresEl) return;
  if (pairCountdownTimer) {
    clearInterval(pairCountdownTimer);
    pairCountdownTimer = null;
  }
  let remaining = Math.max(0, Number(seconds || 0));
  pairExpiresEl.textContent = String(remaining);
  pairCountdownTimer = setInterval(() => {
    remaining -= 1;
    pairExpiresEl.textContent = String(Math.max(0, remaining));
    if (remaining <= 0 && pairCountdownTimer) {
      clearInterval(pairCountdownTimer);
      pairCountdownTimer = null;
      _setPairStatus("Pairing code expired. Generate a new QR.");
    }
  }, 1000);
}

async function useTailscaleBase() {
  _setPairStatus("Detecting Tailscale IP…");
  const info = await _fetchNetInfo();
  if (!info || !info.tailscale_ip) {
    _setPairStatus("Tailscale IP not detected on this laptop.");
    _syncPairRouteUi();
    return;
  }
  const port = window.location.port || "8787";
  pairBaseUrlEl.value = `http://${info.tailscale_ip}:${port}`;
  _setPairStatus("Using Tailscale base URL.");
  _syncPairRouteUi();
}

async function useLanBase() {
  _setPairStatus("Detecting LAN IP…");
  const info = await _fetchNetInfo();
  if (!info || !info.lan_ip) {
    _setPairStatus("LAN IP not detected.");
    _syncPairRouteUi();
    return;
  }
  const port = window.location.port || "8787";
  pairBaseUrlEl.value = `http://${info.lan_ip}:${port}`;
  _setPairStatus("Using LAN base URL.");
  _syncPairRouteUi();
}

async function generatePairQr() {
  if (!pairBaseUrlEl || !pairQrImgEl || !pairLinkEl) return;

  const base = _normalizeBaseUrl(pairBaseUrlEl.value || window.location.origin);
  if (!base) {
    _setPairStatus("Base URL is required.");
    return;
  }
  const routeKind = _pairRouteKind(base, netInfo);
  if (pairTailscaleOnly && routeKind !== "tailscale") {
    _syncPairRouteUi();
    _setPairStatus("Blocked by Tailscale-only mode. Tap 'Use Tailscale' first.");
    return;
  }
  if (routeKind === "local") {
    _setPairStatus("Localhost cannot be scanned from phone. Use LAN or Tailscale.");
    _syncPairRouteUi();
    return;
  }

  _setPairStatus("Generating one-time code…");
  try {
    const r = await apiFetch('/auth/pair/create', { method: "POST" });
    const j = await r.json();
    if (!j.ok) {
      _setPairStatus(j.detail || "Failed to create pairing code.");
      return;
    }
    const url = `${base}/auth/pair/consume?code=${encodeURIComponent(j.code)}`;
    pairLinkEl.textContent = url;
    pairQrImgEl.src = `/auth/pair/qr.svg?data=${encodeURIComponent(url)}&ts=${Date.now()}`;
    pairQrImgEl.style.display = "block";
    _startPairCountdown(j.expires_in || 0);
    _setPairStatus("QR ready. Scan from phone.");
    _syncPairRouteUi();
  } catch (_e) {
    _setPairStatus("Pairing request failed.");
  }
}

pairTailscaleOnly = _storageGetBool(PAIR_TS_ONLY_KEY, false);
_syncTailscaleOnlyBtn();
_syncPairNetworkUi();

function updateSessionSelect(sessions) {
  sessionSel.innerHTML = "";
  if (!sessions || sessions.length === 0) {
    const opt = document.createElement('option');
    opt.value = "";
    opt.textContent = "No sessions";
    sessionSel.appendChild(opt);
    sessionSel.disabled = true;
    closeSessionBtn.disabled = true;
    return;
  }

  sessionSel.disabled = false;
  closeSessionBtn.disabled = false;
  for (const s of sessions) {
    const opt = document.createElement('option');
    opt.value = s;
    opt.textContent = s;
    sessionSel.appendChild(opt);
  }
}

async function refreshPanes() {
  statusEl.textContent = "Refreshing…";
  refreshTmuxHealth();
  const r = await apiFetch('/tmux/panes');
  const j = await r.json();

  paneSel.innerHTML = "";
  paneSessionMap.clear();
  if (!j.ok) {
    statusEl.textContent = "Failed to list panes";
    _setConsoleText(outEl, JSON.stringify(j, null, 2));
    return;
  }

  const panes = j.panes || [];
  panes.sort((a,b) => (b.active - a.active));
  const sessions = new Set();

  for (const p of panes) {
    const opt = document.createElement('option');
    opt.value = p.pane_id;
    opt.textContent = `${p.session} | ${p.pane_id} | ${p.current_command} | ${p.current_path}${p.active ? " (active)" : ""}`;
    paneSel.appendChild(opt);
    sessions.add(p.session);
    paneSessionMap.set(p.pane_id, p.session);
  }

  statusEl.textContent = `Found ${panes.length} panes`;
  updateSessionSelect([...sessions].sort());

  if (panes.length) {
    paneSel.disabled = false;
    fetchScreen();
    tmuxStream.intervalMs = _readIntValue(tmuxStreamRateEl, tmuxStream.intervalMs);
    _startPaneStream(tmuxStream, paneSel.value, outEl, tmuxStreamStatusEl);
  } else {
    paneSel.disabled = true;
    _stopPaneStream(tmuxStream, tmuxStreamStatusEl);
    _setConsoleText(outEl, "No panes available. Create a session to get started.");
  }
}

async function createSession() {
  const nameEl = document.getElementById('sessionName');
  const name = (nameEl.value || "").trim();
  statusEl.textContent = "Creating session…";

  const payload = name ? { name } : {};
  const r = await apiFetch('/tmux/session', {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload)
  });
  const j = await r.json();
  if (!j.ok) {
    statusEl.textContent = "Failed to create session";
    _setConsoleText(outEl, JSON.stringify(j, null, 2));
    return;
  }
  nameEl.value = "";
  statusEl.textContent = j.name ? `Session created: ${j.name}` : "Session created";
  refreshPanes();
}

async function closeSession() {
  const name = sessionSel.value;
  if (!name) return;
  if (!confirm(`Close session \"${name}\"?`)) return;

  statusEl.textContent = "Closing session…";
  const r = await apiFetch(`/tmux/session/${encodeURIComponent(name)}`, { method: "DELETE" });
  const j = await r.json();
  if (!j.ok) {
    statusEl.textContent = "Failed to close session";
    _setConsoleText(outEl, JSON.stringify(j, null, 2));
    return;
  }
  statusEl.textContent = `Session closed: ${name}`;
  refreshPanes();
}

async function debugTmux() {
  statusEl.textContent = "Collecting tmux debug…";
  const r = await apiFetch('/tmux/debug');
  const j = await r.json();
  statusEl.textContent = "Debug collected";
  _setConsoleText(outEl, JSON.stringify(j, null, 2));
}

async function refreshTmuxHealth() {
  try {
    const r = await apiFetch('/tmux/health');
    const j = await r.json();
    if (!j.ok) {
      tmuxBadgeEl.textContent = "tmux: error";
      tmuxBadgeEl.className = "badge err";
      return;
    }
    updateSessionSelect(j.sessions || []);
    if (j.state === "no_server") {
      tmuxBadgeEl.textContent = "tmux: not running";
      tmuxBadgeEl.className = "badge warn";
      return;
    }
    if (j.count === 0) {
      tmuxBadgeEl.textContent = "tmux: no sessions";
      tmuxBadgeEl.className = "badge warn";
      return;
    }
    tmuxBadgeEl.textContent = `tmux: ${j.count} session${j.count === 1 ? "" : "s"}`;
    tmuxBadgeEl.className = "badge ok";
  } catch (e) {
    tmuxBadgeEl.textContent = "tmux: error";
    tmuxBadgeEl.className = "badge err";
  }
}

async function fetchScreen() {
  const pane = paneSel.value;
  if (!pane) return;
  const url = `/tmux/pane/${encPaneId(pane)}/screen`;
  const r = await apiFetch(url);
  const j = await r.json();
  _setConsoleText(outEl, j.ok ? (j.text || "") : JSON.stringify(j, null, 2));
}

async function sendMsg() {
  const pane = paneSel.value;
  const msgEl = document.getElementById('msg');
  const text = msgEl.value;
  if (!pane || !text) return;

  const r = await apiFetch(`/tmux/pane/${encPaneId(pane)}/send`, {
    method: "POST",
    headers: { "Content-Type": "text/plain" },
    body: text
  });
  const j = await r.json();
  if (!j.ok) {
    _setConsoleText(outEl, JSON.stringify(j, null, 2));
    return;
  }
  msgEl.value = "";
  if (tmuxStream.enabled) {
    tmuxStream.intervalMs = _readIntValue(tmuxStreamRateEl, tmuxStream.intervalMs);
    _startPaneStream(tmuxStream, pane, outEl, tmuxStreamStatusEl);
  } else {
    setTimeout(fetchScreen, 500);
  }
}

async function ctrlC() {
  const pane = paneSel.value;
  if (!pane) return;
  const r = await apiFetch(`/tmux/pane/${encPaneId(pane)}/ctrlc`, { method: "POST" });
  const j = await r.json();
  if (!j.ok) _setConsoleText(outEl, JSON.stringify(j, null, 2));
  if (tmuxStream.enabled) {
    tmuxStream.intervalMs = _readIntValue(tmuxStreamRateEl, tmuxStream.intervalMs);
    _startPaneStream(tmuxStream, pane, outEl, tmuxStreamStatusEl);
  } else {
    setTimeout(fetchScreen, 600);
  }
}

async function takeShot() {
  statusEl.textContent = "Taking screenshot…";
  shotImg.src = `/shot?ts=${Date.now()}`;
  shotImg.style.display = "block";
  shotImg.onload = () => { statusEl.textContent = "Screenshot updated"; };
  shotImg.onerror = () => { statusEl.textContent = "Screenshot failed"; };
}

async function loadRuns() {
  const r = await apiFetch('/codex/runs');
  const j = await r.json();
  if (!j.ok) {
    runsListEl.textContent = JSON.stringify(j, null, 2);
    return;
  }
  const items = j.runs || [];
  runsListEl.innerHTML = items.map(x => {
    const dur = x.duration_s == null ? "" : `${x.duration_s}s`;
    const p = (x.prompt || "").slice(0,80).replace(/</g,"&lt;");
    return `<div>• ${x.id} | ${x.status} | ${dur} | ${p}</div>`;
  }).join("");
}

async function runExec() {
  const prompt = document.getElementById('execPrompt').value.trim();
  if (!prompt) return;

  execBtn.disabled = true;
  execStatusEl.textContent = "Starting…";
  execOutEl.textContent = "";

  const r = await apiFetch('/codex/exec', {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ prompt })
  });
  const j = await r.json();
  if (!j.ok) {
    execOutEl.textContent = JSON.stringify(j, null, 2);
    execBtn.disabled = false;
    return;
  }

  const id = j.id;
  execStatusEl.textContent = `Running: ${id}`;

  const poll = async () => {
    const rr = await apiFetch(`/codex/run/${id}`);
    const jj = await rr.json();
    if (!jj.ok) {
      execOutEl.textContent = JSON.stringify(jj, null, 2);
      execBtn.disabled = false;
      return;
    }
    execStatusEl.textContent = `Status: ${jj.status}`;
    execOutEl.textContent = jj.output || "";
    if (jj.status === "running") {
      setTimeout(poll, 1000);
    } else {
      execBtn.disabled = false;
      loadRuns();
    }
  };
  setTimeout(poll, 600);
}

function downloadWsl() {
  const p = document.getElementById('dlPath').value.trim();
  if (!p) return;
  window.open(`/wsl/file?path=${encodeURIComponent(p)}`, "_blank");
}

async function uploadWsl() {
  const f = document.getElementById('upFile').files[0];
  const dest = document.getElementById('upDest').value.trim();
  if (!f) return;

  fileStatusEl.textContent = "Uploading…";
  fileOutEl.textContent = "";

  const fd = new FormData();
  fd.append("file", f);
  if (dest) fd.append("dest", dest);

  const r = await apiFetch("/wsl/upload", { method: "POST", body: fd });
  const j = await r.json();
  if (!j.ok) {
    fileStatusEl.textContent = "Upload failed";
    fileOutEl.textContent = JSON.stringify(j, null, 2);
    return;
  }
  fileStatusEl.textContent = "Uploaded";
  fileOutEl.textContent = `Saved as: ${j.saved_path}`;
}

async function refreshCodexSessions() {
  try {
    const prevSelected = codexSessionSelectEl ? (codexSessionSelectEl.value || "") : "";
    const r = await apiFetch('/codex/sessions');
    const j = await r.json();
    if (!j.ok) {
      codexSessionBadgeEl.textContent = "error";
      codexSessionBadgeEl.className = "badge err";
      return;
    }
    const items = j.sessions || [];
    codexSessionPaneMap.clear();
    codexSessionSelectEl.innerHTML = "";
    for (const s of items) {
      if (s && s.session) codexSessionPaneMap.set(s.session, s.pane_id);
      const opt = document.createElement('option');
      opt.value = s.session;
      opt.textContent = `${s.session} | ${s.state} | ${s.current_command}`;
      codexSessionSelectEl.appendChild(opt);
    }
    if (prevSelected && codexSessionPaneMap.has(prevSelected)) {
      codexSessionSelectEl.value = prevSelected;
    }
    codexSessionBadgeEl.textContent = `${items.length} session${items.length === 1 ? "" : "s"}`;
    codexSessionBadgeEl.className = items.length ? "badge running" : "badge warn";
    if (!items.length) {
      _stopPaneStream(codexStream, codexStreamStatusEl);
      _setConsoleText(codexSessionOutEl, "No codex sessions found. Create one to get started.");
      codexSessionStateEl.textContent = "";
      return;
    }

    const selected = codexSessionSelectEl.value;
    const selItem = items.find(x => x.session === selected) || items[0];
    if (selItem) codexSessionStateEl.textContent = `${selItem.state} | cmd: ${selItem.current_command}`;

    // If streaming is enabled, stream the selected session's pane output.
    codexStream.intervalMs = _readIntValue(codexStreamRateEl, codexStream.intervalMs);
    const paneId = codexSessionPaneMap.get(selected) || (selItem ? selItem.pane_id : "");
    _startPaneStream(codexStream, paneId, codexSessionOutEl, codexStreamStatusEl);

    // Otherwise, fall back to one-shot screen capture.
    if (!codexStream.enabled) await loadCodexSessionScreen();
  } catch (_e) {
    codexSessionBadgeEl.textContent = "error";
    codexSessionBadgeEl.className = "badge err";
  }
}

async function createCodexSession() {
  const name = (codexSessionNameEl.value || "").trim();
  const cwd = (codexSessionCwdEl.value || "").trim();
  const payload = {};
  if (name) payload.name = name;
  if (cwd) payload.cwd = cwd;
  const r = await apiFetch('/codex/session', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload)
  });
  const j = await r.json();
  if (!j.ok) {
    codexSessionStateEl.textContent = j.detail || j.error || "create failed";
    return;
  }
  codexSessionNameEl.value = "";
  codexSessionStateEl.textContent = `Created ${j.session}`;
  await refreshCodexSessions();
}

async function closeCodexSession() {
  const session = codexSessionSelectEl.value;
  if (!session) return;
  const r = await apiFetch(`/codex/session/${encodeURIComponent(session)}`, { method: 'DELETE' });
  const j = await r.json();
  codexSessionStateEl.textContent = j.ok ? `Closed ${session}` : (j.detail || "close failed");
  await refreshCodexSessions();
}

async function sendCodexSessionPrompt() {
  const session = codexSessionSelectEl.value;
  const text = (codexSessionPromptEl.value || "").trim();
  if (!session || !text) return;
  const r = await apiFetch(`/codex/session/${encodeURIComponent(session)}/send`, {
    method: 'POST',
    headers: { 'Content-Type': 'text/plain' },
    body: text
  });
  const j = await r.json();
  if (!j.ok) {
    codexSessionStateEl.textContent = j.detail || "send failed";
    return;
  }
  codexSessionPromptEl.value = "";
  codexSessionStateEl.textContent = "Prompt sent.";
  if (codexStream.enabled) {
    codexStream.intervalMs = _readIntValue(codexStreamRateEl, codexStream.intervalMs);
    const paneId = codexSessionPaneMap.get(session) || "";
    _startPaneStream(codexStream, paneId, codexSessionOutEl, codexStreamStatusEl);
  } else {
    setTimeout(loadCodexSessionScreen, 500);
  }
}

async function sendCtrlCToSession() {
  const session = codexSessionSelectEl.value;
  if (!session) return;
  const r = await apiFetch(`/codex/session/${encodeURIComponent(session)}/interrupt`, { method: 'POST' });
  const j = await r.json();
  codexSessionStateEl.textContent = j.ok ? "Interrupt sent." : (j.detail || "interrupt failed");
  if (codexStream.enabled) {
    codexStream.intervalMs = _readIntValue(codexStreamRateEl, codexStream.intervalMs);
    const paneId = codexSessionPaneMap.get(session) || "";
    _startPaneStream(codexStream, paneId, codexSessionOutEl, codexStreamStatusEl);
  } else {
    setTimeout(loadCodexSessionScreen, 600);
  }
}

async function uploadCodexSessionImage() {
  const session = codexSessionSelectEl.value;
  const file = codexSessionImageEl.files[0];
  if (!session || !file) return;
  const prompt = (codexSessionImagePromptEl.value || "").trim();
  const fd = new FormData();
  fd.append("file", file);
  if (prompt) fd.append("prompt", prompt);
  const r = await apiFetch(`/codex/session/${encodeURIComponent(session)}/image`, {
    method: 'POST',
    body: fd
  });
  const j = await r.json();
  codexSessionStateEl.textContent = j.ok ? `Image sent: ${j.saved_path}` : (j.detail || "image send failed");
  if (j.ok) {
    codexSessionImageEl.value = "";
    codexSessionImagePromptEl.value = "";
    if (codexStream.enabled) {
      codexStream.intervalMs = _readIntValue(codexStreamRateEl, codexStream.intervalMs);
      const paneId = codexSessionPaneMap.get(session) || "";
      _startPaneStream(codexStream, paneId, codexSessionOutEl, codexStreamStatusEl);
    } else {
      setTimeout(loadCodexSessionScreen, 700);
    }
  }
}

async function loadCodexSessionScreen() {
  const session = codexSessionSelectEl.value;
  if (!session) {
    _setConsoleText(codexSessionOutEl, "No active codex session selected.");
    return;
  }
  const r = await apiFetch(`/codex/session/${encodeURIComponent(session)}/screen`);
  const j = await r.json();
  if (!j.ok) {
    _setConsoleText(codexSessionOutEl, JSON.stringify(j, null, 2));
    return;
  }
  codexSessionStateEl.textContent = `${j.state} | cmd: ${j.current_command}`;
  _setConsoleText(codexSessionOutEl, j.text || "(empty)");
}

async function loadDesktopInfo() {
  try {
    const r = await apiFetch('/desktop/info');
    const j = await r.json();
    if (!j.ok) {
      _updateDesktopStatus(j.detail || "desktop unavailable");
      return;
    }
    desktopInfo = j;
    _updateDesktopStatus();
  } catch (_e) {
    _updateDesktopStatus("desktop unavailable");
  }
}

async function desktopDiagnose(reason = "") {
  if (!desktopModeEnabled) {
    _updateDesktopStatus("desktop off");
    return;
  }
  // Throttle repeated error diagnostics (mobile networks can be noisy).
  const now = Date.now();
  if (desktopDiagInFlight) return;
  if (now - desktopLastDiagMs < 3500) return;
  desktopLastDiagMs = now;
  desktopDiagInFlight = true;
  try {
    await checkAuthStatus();
    if (authState && authState.auth_required && !authState.authenticated) {
      _updateDesktopStatus("login required");
      setAuthGate(true, "Login required for desktop stream.");
      return;
    }
    const r = await apiFetch('/desktop/info');
    const j = await r.json();
    if (!j || !j.ok) {
      _updateDesktopStatus((j && (j.detail || j.error)) ? (j.detail || j.error) : "desktop unavailable");
      return;
    }
    desktopInfo = j;
    _updateDesktopStatus(reason ? `ok (${reason})` : "ok");
  } catch (_e) {
    _updateDesktopStatus("desktop unavailable");
  } finally {
    desktopDiagInFlight = false;
  }
}

async function refreshDesktopFrame() {
  if (!deskImgEl) return;
  if (!desktopModeEnabled) {
    desktopFrameInFlight = false;
    const cur = String(deskImgEl.getAttribute('src') || "");
    if (cur !== desktopBlankImage) deskImgEl.setAttribute('src', desktopBlankImage);
    _updateDesktopStatus("desktop off");
    return;
  }
  if (!desktopInfo) loadDesktopInfo();
  // Keep desktop feed always on via server stream, independent of JS timers.
  const target = desktopStreamUrl;
  const current = String(deskImgEl.getAttribute('src') || "");
  if (current !== target) {
    desktopFrameInFlight = true;
    desktopLastReqMs = Date.now();
    desktopReqCount += 1;
    deskImgEl.src = target;
  }
}

function toggleDesktopAuto() {
  desktopAutoEnabled = !desktopAutoEnabled;
  _syncDesktopAutoUI();
  if (desktopAutoEnabled) {
    desktopDiagnose("auto on");
    refreshDesktopFrame();
    _scheduleNextDesktopFrame();
  } else if (desktopAutoTimer) {
    clearTimeout(desktopAutoTimer);
    desktopAutoTimer = null;
    desktopFrameInFlight = false;
  }
}

function _isProbablyMobile() {
  try {
    return window.matchMedia && window.matchMedia('(pointer:coarse)').matches;
  } catch (_e) {
    return false;
  }
}

function _updateDesktopStatus(extra = "") {
  if (!deskStatusEl) return;
  const parts = [];
  parts.push(desktopModeEnabled ? "desktop on" : "desktop off");
  if (desktopInfo && desktopInfo.width && desktopInfo.height) {
    parts.push(`${desktopInfo.width}x${desktopInfo.height}`);
  }
  parts.push(desktopAutoEnabled ? `auto ${desktopAutoMs}ms` : "auto off");
  if (desktopReqCount || desktopOkCount || desktopErrCount) {
    parts.push(`req ${desktopReqCount} ok ${desktopOkCount} err ${desktopErrCount}`);
  }
  if (desktopFrameInFlight) {
    parts.push("pending");
  }
  if (desktopLastFrameMs) {
    try {
      const t = new Date(desktopLastFrameMs).toLocaleTimeString();
      parts.push(`frame ${t}`);
    } catch (_e) {}
  }
  if (extra) parts.push(extra);
  deskStatusEl.textContent = parts.join(" | ");
}

function _applyDesktopModeUI() {
  try {
    if (document && document.body && document.body.classList) {
      document.body.classList.toggle("desktop-on", !!desktopModeEnabled);
      document.body.classList.toggle("desktop-off", !desktopModeEnabled);
    }
  } catch (_e) {}

  if (deskModeBtnEl) {
    deskModeBtnEl.textContent = desktopModeEnabled ? "Control: On" : "Control: Off";
    deskModeBtnEl.classList.add("toggle-btn");
    deskModeBtnEl.classList.toggle("state-on", !!desktopModeEnabled);
    deskModeBtnEl.classList.toggle("state-off", !desktopModeEnabled);
    deskModeBtnEl.classList.toggle("desktop-mode-btn-active", !!desktopModeEnabled);
  }
  if (deskModeBadgeEl) {
    deskModeBadgeEl.textContent = desktopModeEnabled ? desktopLiveBadgeText : "Desktop stream paused";
    deskModeBadgeEl.classList.toggle("running", !!desktopModeEnabled);
    deskModeBadgeEl.classList.toggle("warn", !desktopModeEnabled);
  }
  if (!desktopModeEnabled && deskImgEl) {
    const cur = String(deskImgEl.getAttribute('src') || "");
    if (cur !== desktopBlankImage) deskImgEl.setAttribute('src', desktopBlankImage);
  }
  _updateDesktopStatus();
}

function _desktopStreamUrlFor(fps, level) {
  const qs = new URLSearchParams();
  qs.set("fps", String(fps));
  qs.set("level", String(level));
  return `/desktop/stream?${qs.toString()}`;
}

function _syncDesktopStreamLink() {
  if (deskStreamLinkEl) deskStreamLinkEl.href = desktopStreamUrl;
}

function _setDesktopPerf(profile, refresh = false) {
  const profiles = {
    responsive: { fps: 4, level: 2 },
    balanced: { fps: 3, level: 3 },
    saver: { fps: 2, level: 6 },
  };
  const p = profiles[profile] || profiles.balanced;
  desktopStreamUrl = _desktopStreamUrlFor(p.fps, p.level);
  _syncDesktopStreamLink();
  if (deskPerfEl && deskPerfEl.value !== profile) deskPerfEl.value = profile;
  if (refresh && desktopModeEnabled) {
    desktopFrameInFlight = false;
    refreshDesktopFrame();
  }
}

function _initDesktopPerfFromUrl() {
  try {
    const u = new URL(desktopStreamUrl, window.location.origin);
    const fps = Number(u.searchParams.get("fps") || "3");
    const level = Number(u.searchParams.get("level") || "3");
    if (fps >= 3.8 && level <= 2.5) return _setDesktopPerf("responsive", false);
    if (fps <= 2.2 || level >= 5.5) return _setDesktopPerf("saver", false);
  } catch (_e) {}
  _setDesktopPerf("balanced", false);
}

async function toggleDesktopMode() {
  const next = !desktopModeEnabled;
  try {
    const r = await apiFetch('/desktop/mode', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ enabled: next })
    });
    const j = await r.json();
    if (!j || !j.ok) {
      _updateDesktopStatus((j && (j.detail || j.error)) ? (j.detail || j.error) : "mode change failed");
      return;
    }
    desktopModeEnabled = !!j.enabled;
    _applyDesktopModeUI();
    if (desktopModeEnabled) {
      refreshDesktopFrame();
      desktopDiagnose("mode on");
      if (desktopAutoEnabled) _scheduleNextDesktopFrame();
    } else {
      if (desktopAutoTimer) {
        clearTimeout(desktopAutoTimer);
        desktopAutoTimer = null;
      }
      desktopFrameInFlight = false;
      _updateDesktopStatus("desktop off");
    }
  } catch (_e) {
    _updateDesktopStatus("mode change failed");
  }
}

function _syncDesktopAutoUI() {
  if (deskAutoBtnEl) {
    deskAutoBtnEl.textContent = desktopAutoEnabled ? "Auto: On" : "Auto: Off";
    deskAutoBtnEl.classList.toggle("primary", desktopAutoEnabled);
  }
  _updateDesktopStatus();
}

function _scheduleNextDesktopFrame(delayMs = null) {
  if (!desktopModeEnabled) return;
  if (!desktopAutoEnabled) return;
  if (desktopAutoTimer) clearTimeout(desktopAutoTimer);
  const ms = (delayMs != null ? delayMs : desktopAutoMs);
  desktopAutoTimer = setTimeout(() => {
    if (!desktopModeEnabled) return;
    if (!desktopAutoEnabled) return;
    if (document.visibilityState !== 'visible') {
      _scheduleNextDesktopFrame(ms);
      return;
    }
    // Avoid piling up requests; if a fetch seems stuck for too long, retry.
    const now = Date.now();
    const stuckMs = Math.max(8000, desktopAutoMs * 8);
    if (desktopFrameInFlight && (now - desktopLastReqMs) < stuckMs) {
      _scheduleNextDesktopFrame(ms);
      return;
    }
    if (desktopFrameInFlight && (now - desktopLastReqMs) >= stuckMs) {
      desktopFrameInFlight = false;
      _updateDesktopStatus("stalled; retrying");
    }
    refreshDesktopFrame();
    _scheduleNextDesktopFrame(ms);
  }, Math.max(250, ms));
}

// Turn the screenshot <img> into a self-throttling refresh loop when Auto is on.
// This avoids request pile-ups on slow networks and reduces flakiness on mobile.
if (deskImgEl) {
  deskImgEl.addEventListener('load', () => {
    desktopLastFrameMs = Date.now();
    desktopFrameInFlight = false;
    desktopOkCount += 1;
    _updateDesktopStatus();
  });
  deskImgEl.addEventListener('error', () => {
    desktopFrameInFlight = false;
    desktopErrCount += 1;
    _updateDesktopStatus("stream error");
    desktopDiagnose("stream error");
    _scheduleNextDesktopFrame(Math.min(4000, desktopAutoMs * 2));
  });
}

if (deskRateEl) {
  deskRateEl.addEventListener('change', () => {
    const next = Number(deskRateEl.value || "1200");
    if (!Number.isFinite(next) || next <= 0) return;
    desktopAutoMs = next;
    _syncDesktopAutoUI();
    if (desktopAutoEnabled) _scheduleNextDesktopFrame();
  });
  try {
    const initial = Number(deskRateEl.value || "1200");
    if (Number.isFinite(initial) && initial > 0) desktopAutoMs = initial;
  } catch (_e) {}
}

_initDesktopPerfFromUrl();
if (deskPerfEl) {
  deskPerfEl.addEventListener('change', () => {
    _setDesktopPerf(deskPerfEl.value || "balanced", true);
  });
}
_syncDesktopStreamLink();

_syncDesktopAutoUI();
_applyDesktopModeUI();
bindDesktopAutoButton();

function pointToDesktopXY(clientX, clientY) {
  if (!desktopInfo) return null;
  const rect = deskImgEl.getBoundingClientRect();
  if (!rect.width || !rect.height) return null;
  const relX = Math.max(0, Math.min(rect.width - 1, clientX - rect.left));
  const relY = Math.max(0, Math.min(rect.height - 1, clientY - rect.top));
  const x = Math.round((relX / rect.width) * desktopInfo.width);
  const y = Math.round((relY / rect.height) * desktopInfo.height);
  return { x, y };
}

deskImgEl.addEventListener('click', async (e) => {
  const p = pointToDesktopXY(e.clientX, e.clientY);
  if (!p) return;
  lastDesktopPoint = p;
  await desktopClick('left', false, p);
  refreshDesktopFrame();
});

deskImgEl.addEventListener('touchend', async (e) => {
  const t = e.changedTouches && e.changedTouches[0];
  if (!t) return;
  const p = pointToDesktopXY(t.clientX, t.clientY);
  if (!p) return;
  lastDesktopPoint = p;
  await desktopClick('left', false, p);
  refreshDesktopFrame();
});

async function desktopClick(button = 'left', double = false, explicitPoint = null) {
  if (!desktopModeEnabled) {
    _updateDesktopStatus("desktop off");
    return;
  }
  const p = explicitPoint || lastDesktopPoint;
  const payload = { button, double };
  if (p) {
    payload.x = p.x;
    payload.y = p.y;
  }
  const r = await apiFetch('/desktop/input/click', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload)
  });
  const j = await r.json();
  deskStatusEl.textContent = j.ok ? `click ${button}` : (j.detail || "click failed");
  if (j.ok) refreshDesktopFrame();
}

async function desktopScroll(delta) {
  if (!desktopModeEnabled) {
    _updateDesktopStatus("desktop off");
    return;
  }
  const r = await apiFetch('/desktop/input/scroll', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ delta })
  });
  const j = await r.json();
  deskStatusEl.textContent = j.ok ? `scroll ${delta}` : (j.detail || "scroll failed");
  if (j.ok) refreshDesktopFrame();
}

async function desktopSendKey() {
  if (!desktopModeEnabled) {
    _updateDesktopStatus("desktop off");
    return;
  }
  const key = deskKeyEl.value;
  const r = await apiFetch('/desktop/input/key', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ key })
  });
  const j = await r.json();
  deskStatusEl.textContent = j.ok ? `sent ${key}` : (j.detail || "key failed");
  if (j.ok) refreshDesktopFrame();
}

function _queueLive(fn) {
  // Keep keystrokes ordered even if network responses return out of order.
  liveKeyQueue = liveKeyQueue.then(fn).catch((_e) => {});
}

async function desktopQuickKey(key) {
  if (!desktopModeEnabled) {
    _updateDesktopStatus("desktop off");
    return;
  }
  const r = await apiFetch('/desktop/input/key', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ key })
  });
  const j = await r.json();
  if (!j.ok) deskStatusEl.textContent = j.detail || "key failed";
}

async function desktopEdit(backspaceCount, text) {
  if (!desktopModeEnabled) {
    _updateDesktopStatus("desktop off");
    return;
  }
  let backspace = Math.max(0, Number(backspaceCount || 0));
  let t = String(text || "");
  if (!backspace && !t) return;

  const BS_CHUNK = 200;   // server max
  const TXT_CHUNK = 400;  // keep under server max (500)

  async function sendOnce(bs, chunk) {
    const r = await apiFetch('/desktop/input/edit', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ backspace: bs, text: chunk })
    });
    let j = null;
    try { j = await r.json(); } catch (_e) { j = { ok: false, detail: `Bad response (${r.status})` }; }
    if (!r.ok || !j || !j.ok) {
      deskStatusEl.textContent = (j && j.detail) ? j.detail : "edit failed";
      throw new Error("edit_failed");
    }
  }

  while (backspace > 0) {
    const bs = Math.min(backspace, BS_CHUNK);
    backspace -= bs;
    await sendOnce(bs, "");
  }
  while (t.length > 0) {
    const chunk = t.slice(0, TXT_CHUNK);
    t = t.slice(chunk.length);
    await sendOnce(0, chunk);
  }
}

function resetLiveBuffer() {
  if (!deskLiveInputEl) return;
  liveLastValue = "";
  deskLiveInputEl.value = "";
  try { deskLiveInputEl.focus(); } catch (_e) {}
}

async function pasteToLive() {
  if (!deskLiveInputEl) return;

  // Clipboard API usually requires HTTPS; on HTTP we fall back to a prompt.
  let text = "";
  try {
    if (navigator.clipboard && navigator.clipboard.readText) {
      text = await navigator.clipboard.readText();
    }
  } catch (_e) {}
  if (!text) {
    text = window.prompt("Paste text to send to desktop:") || "";
  }

  // Normalize newlines for consistency.
  text = String(text || "").replace(/\\r\\n/g, "\\n");
  if (!text) return;

  // Keep local mirror in sync with what we send.
  liveLastValue = String(liveLastValue || "") + text;
  if (liveLastValue.length > 4000) liveLastValue = liveLastValue.slice(-4000);
  deskLiveInputEl.value = liveLastValue;
  _forceLiveCaretEnd();
  _queueLive(() => desktopEdit(0, text));
}

function _forceLiveCaretEnd() {
  if (!deskLiveInputEl) return;
  try {
    const n = (deskLiveInputEl.value || "").length;
    deskLiveInputEl.setSelectionRange(n, n);
  } catch (_e) {}
}

function _computeTailEdit(prev, next) {
  if (next === prev) return { backspace: 0, text: "" };
  if (next.startsWith(prev)) return { backspace: 0, text: next.slice(prev.length) };
  if (prev.startsWith(next)) return { backspace: prev.length - next.length, text: "" };
  let i = 0;
  while (i < prev.length && i < next.length && prev[i] === next[i]) i++;
  return { backspace: prev.length - i, text: next.slice(i) };
}

function _bindLiveKeyboard() {
  if (!deskLiveInputEl) return;

  liveLastValue = String(deskLiveInputEl.value || "");
  _forceLiveCaretEnd();

  deskLiveInputEl.addEventListener('focus', _forceLiveCaretEnd);
  deskLiveInputEl.addEventListener('click', _forceLiveCaretEnd);
  deskLiveInputEl.addEventListener('select', _forceLiveCaretEnd);

  deskLiveInputEl.addEventListener('keydown', (e) => {
    if (!e) return;
    if (e.ctrlKey || e.metaKey || e.altKey) return;
    if (e.key === "Backspace") {
      e.preventDefault();
      if (liveLastValue) liveLastValue = liveLastValue.slice(0, -1);
      deskLiveInputEl.value = liveLastValue;
      _forceLiveCaretEnd();
      _queueLive(() => desktopEdit(1, ""));
      return;
    }
    if (e.key === "Enter") {
      e.preventDefault();
      liveLastValue = String(liveLastValue || "") + "\\n";
      if (liveLastValue.length > 4000) liveLastValue = liveLastValue.slice(-4000);
      deskLiveInputEl.value = liveLastValue;
      _forceLiveCaretEnd();
      _queueLive(() => desktopQuickKey("enter"));
      return;
    }
  });

  deskLiveInputEl.addEventListener('beforeinput', (e) => {
    if (!e) return;
    const t = String(e.inputType || "");
    const data = (typeof e.data === "string") ? e.data : "";
    if (t === "insertLineBreak") {
      e.preventDefault();
      liveLastValue = String(liveLastValue || "") + "\\n";
      if (liveLastValue.length > 4000) liveLastValue = liveLastValue.slice(-4000);
      deskLiveInputEl.value = liveLastValue;
      _forceLiveCaretEnd();
      _queueLive(() => desktopQuickKey("enter"));
      return;
    }
    if (t === "deleteContentBackward") {
      e.preventDefault();
      if (liveLastValue) liveLastValue = liveLastValue.slice(0, -1);
      deskLiveInputEl.value = liveLastValue;
      _forceLiveCaretEnd();
      _queueLive(() => desktopEdit(1, ""));
      return;
    }
    if (t.startsWith("insert") && data) {
      e.preventDefault();
      const add = String(data || "").replace(/\\r\\n/g, "\\n");
      if (!add) return;
      liveLastValue = String(liveLastValue || "") + add;
      if (liveLastValue.length > 4000) liveLastValue = liveLastValue.slice(-4000);
      deskLiveInputEl.value = liveLastValue;
      _forceLiveCaretEnd();
      _queueLive(() => desktopEdit(0, add));
    }
  });

  deskLiveInputEl.addEventListener('input', (e) => {
    if (e && e.isComposing) return;
    const next = String(deskLiveInputEl.value || "");
    if (next === liveLastValue) {
      _forceLiveCaretEnd();
      return;
    }
    const edit = _computeTailEdit(liveLastValue, next);
    liveLastValue = next;
    if (liveLastValue.length > 4000) liveLastValue = liveLastValue.slice(-4000);
    deskLiveInputEl.value = liveLastValue;
    _forceLiveCaretEnd();
    if (!edit.backspace && !edit.text) return;
    _queueLive(() => desktopEdit(edit.backspace, edit.text));
  });
}

async function bootstrapAll() {
  await Promise.allSettled([
    refreshPanes(),
    loadRuns(),
    refreshCodexSessions(),
    loadDesktopInfo(),
    _fetchNetInfo(),
  ]);
  refreshDesktopFrame();
}

setInterval(() => {
  if (document.visibilityState !== 'visible') return;
  // If SSE streaming is on and connected, avoid extra polling load.
  if (tmuxStream && tmuxStream.enabled && tmuxStream.es) return;
  fetchScreen();
}, 2500);

setInterval(() => {
  if (document.visibilityState === 'visible') refreshTmuxHealth();
}, 10000);

setInterval(() => {
  if (document.visibilityState === 'visible') refreshCodexSessions();
}, 3000);

autoLoginFromHash().finally(() => {
  _bindLiveKeyboard();
  checkAuthStatus().then(() => {
    // --- Stream UI init (tmux + codex) ---
    tmuxStream.intervalMs = _readIntValue(tmuxStreamRateEl, tmuxStream.intervalMs);
    codexStream.intervalMs = _readIntValue(codexStreamRateEl, codexStream.intervalMs);
    _syncStreamBtn(tmuxStreamBtnEl, tmuxStream.enabled);
    _syncStreamBtn(codexStreamBtnEl, codexStream.enabled);
    _setStreamStatus(tmuxStreamStatusEl, tmuxStream.enabled ? "stream: starting…" : "stream: off");
    _setStreamStatus(codexStreamStatusEl, codexStream.enabled ? "stream: starting…" : "stream: off");

    if (tmuxStreamRateEl) {
      tmuxStreamRateEl.addEventListener('change', () => {
        tmuxStream.intervalMs = _readIntValue(tmuxStreamRateEl, tmuxStream.intervalMs);
        if (tmuxStream.enabled) _startPaneStream(tmuxStream, paneSel.value, outEl, tmuxStreamStatusEl);
      });
    }
    if (codexStreamRateEl) {
      codexStreamRateEl.addEventListener('change', () => {
        codexStream.intervalMs = _readIntValue(codexStreamRateEl, codexStream.intervalMs);
        if (!codexStream.enabled) return;
        const session = codexSessionSelectEl ? (codexSessionSelectEl.value || "") : "";
        const paneId = session ? (codexSessionPaneMap.get(session) || "") : "";
        _startPaneStream(codexStream, paneId, codexSessionOutEl, codexStreamStatusEl);
      });
    }

    bindDesktopAutoButton();

    if (paneSel) {
      paneSel.addEventListener('change', () => {
        if (tmuxStream.enabled) _startPaneStream(tmuxStream, paneSel.value, outEl, tmuxStreamStatusEl);
      });
    }
    if (codexSessionSelectEl) {
      codexSessionSelectEl.addEventListener('change', () => {
        const session = codexSessionSelectEl.value;
        if (codexStream.enabled) {
          const paneId = codexSessionPaneMap.get(session) || "";
          _startPaneStream(codexStream, paneId, codexSessionOutEl, codexStreamStatusEl);
        } else {
          loadCodexSessionScreen();
        }
      });
    }

    document.addEventListener('visibilitychange', () => {
      // EventSource keeps running in the background; pause when hidden to reduce load.
      if (document.visibilityState !== 'visible') {
        _stopPaneStream(tmuxStream, tmuxStreamStatusEl);
        _stopPaneStream(codexStream, codexStreamStatusEl);
        return;
      }
      if (tmuxStream.enabled) _startPaneStream(tmuxStream, paneSel.value, outEl, tmuxStreamStatusEl);
      if (codexStream.enabled) {
        const session = codexSessionSelectEl ? (codexSessionSelectEl.value || "") : "";
        const paneId = session ? (codexSessionPaneMap.get(session) || "") : "";
        _startPaneStream(codexStream, paneId, codexSessionOutEl, codexStreamStatusEl);
      }
      // Desktop <img> can be stale after bfcache/tab switching; refresh once on resume.
      try { refreshDesktopFrame(); } catch (_e) {}
      if (desktopAutoEnabled) _scheduleNextDesktopFrame();
    });

    try {
      document.documentElement.classList.remove('js-basic-mode');
      document.documentElement.classList.add('js-ok-mode');
      const jsBadge = document.getElementById('jsBadge');
      if (jsBadge) jsBadge.textContent = "JS: ok";
    } catch (_e) {}

    bootstrapAll();
    // Mobile defaults: enable auto-refresh after auth so the stream feels "live"
    // without requiring an extra tap.
    if (desktopModeEnabled && _isProbablyMobile() && authState && (!authState.auth_required || authState.authenticated)) {
      desktopAutoEnabled = true;
      _syncDesktopAutoUI();
      refreshDesktopFrame();
      _scheduleNextDesktopFrame();
    }
  });
});
</script>
</body>
</html>
    """
    content = (
        html.replace("__CODEX_DISTRO__", distro)
        .replace("__CODEX_WORKDIR__", workdir)
        .replace("__CODEX_ROOT__", root)
        .replace("__DESKTOP_MODE_CLASS__", desktop_mode_class)
        .replace("__COMPACT_MODE_CLASS__", compact_mode_class)
        .replace("__COMPACT_TOGGLE_HREF__", compact_toggle_href)
        .replace("__COMPACT_TOGGLE_LABEL__", compact_toggle_label)
        .replace("__COMPACT_PILL__", compact_pill)
        .replace("__DESKTOP_MODE_ENABLED__", "true" if desktop_enabled else "false")
        .replace("__DESKTOP_STREAM_URL__", desktop_stream_url)
        .replace("__DESKTOP_STREAM_SRC__", desktop_stream_src)
        .replace("__DESKTOP_LIVE_BADGE__", desktop_live_badge)
        .replace("__DESKTOP_MODE_BADGE_CLASS__", desktop_mode_badge_class)
        .replace("__DESKTOP_MODE_BADGE__", desktop_mode_badge)
        .replace("__DESKTOP_TOGGLE_LABEL__", desktop_toggle_label)
        .replace("__BLANK_IMAGE_DATA_URL__", BLANK_IMAGE_DATA_URL)
        .replace("__DESKTOP_NATIVE_W__", str(desktop_native_w))
        .replace("__DESKTOP_NATIVE_H__", str(desktop_native_h))
        .replace("__DESKTOP_TAP_W__", str(desktop_tap_w))
        .replace("__DESKTOP_TAP_H__", str(desktop_tap_h))
    )
    # Prevent sticky/cached UIs on mobile while we iterate quickly and fix auth issues.
    return HTMLResponse(content=content, headers={"Cache-Control": "no-store"})

# -------------------------
# Auth endpoints
# -------------------------
@app.get("/auth/status")
def auth_status(request: Request):
    token = _auth_token_from_request(request)
    authenticated = _is_valid_auth_token(token)
    return {
        "ok": True,
        "auth_required": CODEX_AUTH_REQUIRED,
        "authenticated": authenticated,
    }

@app.post("/auth/login")
def auth_login(payload: Dict[str, Any] = Body(...)):
    token = (payload.get("token") or "").strip()
    if not _is_valid_auth_token(token):
        return {"ok": False, "error": "unauthorized", "detail": "Invalid token."}
    resp = JSONResponse({"ok": True, "auth_required": CODEX_AUTH_REQUIRED})
    resp.set_cookie(
        key=CODEX_AUTH_COOKIE,
        value=token,
        httponly=True,
        secure=False,
        samesite="lax",
        max_age=60 * 60 * 12,
    )
    return resp

@app.post("/auth/logout")
def auth_logout():
    resp = JSONResponse({"ok": True})
    resp.delete_cookie(CODEX_AUTH_COOKIE)
    return resp

def _safe_next_path(next_path: str) -> str:
    p = (next_path or "").strip()
    if not p.startswith("/"):
        return "/"
    if p.startswith("//"):
        return "/"
    return p

@app.get("/legacy/auth")
def legacy_auth_page():
    return HTMLResponse(
        content="""
<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Fallback Login</title>
    <style>
      body { margin: 0; padding: 16px; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background: #f8fafc; color: #0f172a; }
      .card { background: #fff; border: 1px solid #dfe4ea; border-radius: 12px; padding: 14px; }
      .field { display: flex; flex-direction: column; gap: 6px; margin: 10px 0; }
      input { width: 100%; border: 1px solid #dfe4ea; border-radius: 10px; padding: 10px 12px; font: inherit; }
      button { border-radius: 10px; border: 1px solid #0b4f6c; background: #0b4f6c; color: #fff; padding: 10px 14px; font: inherit; font-weight: 600; }
      a { display: inline-block; margin-top: 12px; color: #0b4f6c; }
    </style>
  </head>
  <body>
    <div class="card">
      <h2 style="margin:0 0 8px;">Fallback Login (No-JS)</h2>
      <form method="post" action="/legacy/auth/login">
        <div class="field">
          <label for="token">Access token</label>
          <input id="token" name="token" type="password" autocomplete="current-password" required />
        </div>
        <input type="hidden" name="next" value="/" />
        <button type="submit">Login</button>
      </form>
      <a href="/">Back to controller</a>
    </div>
  </body>
</html>
        """.strip(),
        headers={"Cache-Control": "no-store"},
    )

@app.post("/legacy/auth/login")
def legacy_auth_login(token: str = Form(""), next: str = Form("/")):
    t = (token or "").strip()
    if not _is_valid_auth_token(t):
        return _legacy_result_page(
            "Fallback Login",
            {"ok": False, "error": "unauthorized", "detail": "Invalid token."},
            401,
        )
    resp = Response(status_code=303, headers={"Location": _safe_next_path(next)})
    resp.set_cookie(
        key=CODEX_AUTH_COOKIE,
        value=t if CODEX_AUTH_REQUIRED else "",
        httponly=True,
        secure=False,
        samesite="lax",
        max_age=60 * 60 * 12,
    )
    return resp

@app.post("/legacy/auth/logout")
def legacy_auth_logout(next: str = Form("/")):
    resp = Response(status_code=303, headers={"Location": _safe_next_path(next)})
    resp.delete_cookie(CODEX_AUTH_COOKIE)
    return resp

# -------------------------
# Pairing + QR endpoints
# -------------------------
@app.get("/net/info")
def net_info():
    # Helper for UI to suggest reachable base URLs (LAN vs Tailscale).
    return {
        "ok": True,
        "lan_ip": guess_lan_ipv4(),
        "tailscale_ip": get_tailscale_ipv4(),
    }


@app.post("/auth/pair/create")
def auth_pair_create():
    if not CODEX_AUTH_REQUIRED:
        return {"ok": True, "code": "", "expires_in": 0}
    data = pairing_create_code()
    return {"ok": True, **data}


@app.post("/auth/pair/exchange")
def auth_pair_exchange(payload: Dict[str, Any] = Body(...)):
    if not CODEX_AUTH_REQUIRED:
        return {"ok": True, "auth_required": False}

    code = (payload.get("code") or payload.get("pair") or "").strip()
    if not pairing_consume_code(code):
        return {"ok": False, "error": "unauthorized", "detail": "Invalid or expired pairing code."}

    resp = JSONResponse({"ok": True, "auth_required": CODEX_AUTH_REQUIRED})
    # Exchange does not reveal CODEX_AUTH_TOKEN to the browser; it only sets the auth cookie.
    resp.set_cookie(
        key=CODEX_AUTH_COOKIE,
        value=CODEX_AUTH_TOKEN,
        httponly=True,
        secure=False,
        samesite="lax",
        max_age=60 * 60 * 12,
    )
    return resp


@app.get("/auth/pair/consume")
def auth_pair_consume(code: str = "", pair: str = ""):
    """
    Pairing endpoint designed for QR scanning.

    Why:
    - Some scanners/in-app browsers drop URL fragments (anything after '#').
    - The previous flow used `/#pair=...` which required JS to run.
    - This endpoint lets the QR link hit the server, set the auth cookie, and redirect.

    Security:
    - Codes are one-time + short-lived (default ~90s).
    - Endpoint is public but only accepts valid pairing codes.
    """
    if not CODEX_AUTH_REQUIRED:
        return Response(status_code=303, headers={"Location": "/"})

    c = (code or pair or "").strip()
    if not pairing_consume_code(c):
        return HTMLResponse(
            content="""
<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Pairing Failed</title>
  </head>
  <body style="font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; padding: 18px;">
    <h2>Pairing Failed</h2>
    <p>This pairing code is invalid or expired. Generate a new QR code from an already-authenticated device.</p>
    <p><a href="/">Open controller</a></p>
  </body>
</html>
            """.strip(),
            status_code=401,
            headers={"Cache-Control": "no-store"},
        )

    resp = Response(status_code=303, headers={"Location": "/"})
    resp.set_cookie(
        key=CODEX_AUTH_COOKIE,
        value=CODEX_AUTH_TOKEN,
        httponly=True,
        secure=False,
        samesite="lax",
        max_age=60 * 60 * 12,
    )
    resp.headers["Cache-Control"] = "no-store"
    return resp


@app.get("/auth/pair/qr.svg")
def auth_pair_qr_svg(data: str = ""):
    data = (data or "").strip()
    if not data:
        raise HTTPException(status_code=400, detail="Missing data.")
    if len(data) > 2048:
        raise HTTPException(status_code=413, detail="QR data too long.")

    try:
        import segno  # lazy import so unit tests don't need this dependency
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"QR generator not installed (segno): {e}")

    qr = segno.make(data, error="m")
    buf = io.BytesIO()
    qr.save(buf, kind="svg", scale=6, border=2)
    return Response(
        content=buf.getvalue(),
        media_type="image/svg+xml",
        headers={"Cache-Control": "no-store"},
    )


@app.get("/auth/pair/qr.png")
def auth_pair_qr_png(data: str = ""):
    """
    PNG variant of the pairing QR generator.
    Useful for native launchers (WinForms) which can easily display bitmap images but not SVG.
    """
    data = (data or "").strip()
    if not data:
        raise HTTPException(status_code=400, detail="Missing data.")
    if len(data) > 2048:
        raise HTTPException(status_code=413, detail="QR data too long.")

    try:
        import segno  # lazy import so unit tests don't need this dependency
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"QR generator not installed (segno): {e}")

    qr = segno.make(data, error="m")
    buf = io.BytesIO()
    # segno's PNG writer is available in our Windows venv; if this fails,
    # the launcher can still fall back to opening the web UI QR panel.
    qr.save(buf, kind="png", scale=6, border=2)
    return Response(
        content=buf.getvalue(),
        media_type="image/png",
        headers={"Cache-Control": "no-store"},
    )

# -------------------------
# Desktop endpoints
# -------------------------
@app.get("/desktop/info")
def desktop_info():
    _ensure_windows_host()
    mon = _desktop_monitor()
    return {"ok": True, **mon}

@app.get("/desktop/shot")
def desktop_shot(level: Optional[int] = None):
    _ensure_windows_host()
    png_level = _clamp(int(level if level is not None else DESKTOP_STREAM_PNG_LEVEL_DEFAULT), 0, 9)
    with mss() as sct:
        mon = sct.monitors[1] if len(sct.monitors) > 1 else sct.monitors[0]
        img = sct.grab(mon)
        rgb = img.rgb
        if SHOW_CURSOR_OVERLAY:
            cur = _desktop_cursor_pos()
            if cur:
                left = int(mon.get("left", 0))
                top = int(mon.get("top", 0))
                rel_x = int(cur[0]) - left
                rel_y = int(cur[1]) - top
                rgb = _overlay_cursor_rgb(rgb, img.size, rel_x, rel_y)
        png_bytes = to_png(rgb, img.size, level=png_level)
        return Response(
            content=png_bytes,
            media_type="image/png",
            headers={"Cache-Control": "no-store"},
        )

@app.get("/desktop/stream")
async def desktop_stream(request: Request, fps: Optional[float] = None, level: Optional[int] = None):
    """
    Continuous desktop stream using multipart/x-mixed-replace.
    This keeps updating even when client-side JS is disabled or broken.
    """
    _ensure_windows_host()
    try:
        fps_val = float(fps if fps is not None else DESKTOP_STREAM_FPS_DEFAULT)
    except Exception:
        fps_val = float(DESKTOP_STREAM_FPS_DEFAULT)
    fps_val = max(0.5, min(fps_val, 8.0))
    png_level = _clamp(int(level if level is not None else DESKTOP_STREAM_PNG_LEVEL_DEFAULT), 0, 9)
    frame_delay = 1.0 / fps_val
    boundary = "frame"

    async def _gen():
        with mss() as sct:
            mon = sct.monitors[1] if len(sct.monitors) > 1 else sct.monitors[0]
            while True:
                if await request.is_disconnected():
                    break
                img = sct.grab(mon)
                rgb = img.rgb
                if SHOW_CURSOR_OVERLAY:
                    cur = _desktop_cursor_pos()
                    if cur:
                        left = int(mon.get("left", 0))
                        top = int(mon.get("top", 0))
                        rel_x = int(cur[0]) - left
                        rel_y = int(cur[1]) - top
                        rgb = _overlay_cursor_rgb(rgb, img.size, rel_x, rel_y)
                png_bytes = to_png(rgb, img.size, level=png_level)
                chunk = (
                    f"--{boundary}\r\n"
                    "Content-Type: image/png\r\n"
                    "Cache-Control: no-store\r\n"
                    f"Content-Length: {len(png_bytes)}\r\n\r\n"
                ).encode("utf-8") + png_bytes + b"\r\n"
                yield chunk
                await asyncio.sleep(frame_delay)

    headers = {
        "Cache-Control": "no-store",
        "Connection": "keep-alive",
        "Pragma": "no-cache",
    }
    return StreamingResponse(
        _gen(),
        media_type=f"multipart/x-mixed-replace; boundary={boundary}",
        headers=headers,
    )

@app.post("/desktop/mode")
def desktop_mode(payload: Dict[str, Any] = Body(...)):
    enabled = _truthy_flag(payload.get("enabled"))
    resp = JSONResponse({"ok": True, "enabled": enabled})
    resp.set_cookie(
        key=CODEX_DESKTOP_MODE_COOKIE,
        value="1" if enabled else "0",
        httponly=True,
        secure=False,
        samesite="lax",
        max_age=60 * 60 * 24 * 30,
    )
    return resp

@app.post("/desktop/input/move")
def desktop_input_move(payload: Dict[str, Any] = Body(...)):
    _ensure_windows_host()
    x = int(payload.get("x", 0))
    y = int(payload.get("y", 0))
    p = _desktop_point(x, y)
    _desktop_move_abs(p["x"], p["y"])
    return {"ok": True, "x": p["rel_x"], "y": p["rel_y"]}

@app.post("/desktop/input/click")
def desktop_input_click(payload: Dict[str, Any] = Body(...)):
    _ensure_windows_host()
    x = payload.get("x")
    y = payload.get("y")
    button = (payload.get("button") or "left").strip().lower()
    double = bool(payload.get("double", False))
    if x is not None and y is not None:
        p = _desktop_point(int(x), int(y))
        _desktop_move_abs(p["x"], p["y"])
    _desktop_click(button=button, double=double)
    return {"ok": True, "button": button, "double": double}

@app.post("/desktop/input/scroll")
def desktop_input_scroll(payload: Dict[str, Any] = Body(...)):
    _ensure_windows_host()
    delta = int(payload.get("delta", 0))
    if delta == 0:
        raise HTTPException(status_code=400, detail="delta is required.")
    _desktop_scroll(delta)
    return {"ok": True, "delta": delta}

@app.post("/desktop/input/type")
def desktop_input_type(payload: Dict[str, Any] = Body(...)):
    _ensure_windows_host()
    text = (payload.get("text") or "")
    if not text:
        raise HTTPException(status_code=400, detail="text is required.")
    r = _desktop_send_text(text)
    if r.get("exit_code") != 0:
        return {"ok": False, "error": "type_failed", "raw": r}
    return {"ok": True}

@app.post("/desktop/input/text")
def desktop_input_text(payload: Dict[str, Any] = Body(...)):
    """
    Real-time typing endpoint (does not touch clipboard).
    """
    _ensure_windows_host()
    text = payload.get("text")
    if not isinstance(text, str):
        raise HTTPException(status_code=400, detail="text must be a string.")
    if not text:
        return {"ok": True, "sent": 0}
    if len(text) > 500:
        raise HTTPException(status_code=400, detail="text too long (max 500).")
    _send_unicode_text(text)
    return {"ok": True, "sent": len(text)}

@app.post("/desktop/input/edit")
def desktop_input_edit(payload: Dict[str, Any] = Body(...)):
    """
    Atomic edit operation for the Live Keyboard:
    - send N backspaces
    - then send a text chunk
    """
    _ensure_windows_host()
    backspace = int(payload.get("backspace", 0) or 0)
    text = payload.get("text") or ""
    if not isinstance(text, str):
        raise HTTPException(status_code=400, detail="text must be a string.")
    if backspace < 0:
        raise HTTPException(status_code=400, detail="backspace must be >= 0.")
    if backspace > 200:
        raise HTTPException(status_code=400, detail="backspace too large (max 200).")
    if len(text) > 500:
        raise HTTPException(status_code=400, detail="text too long (max 500).")

    if backspace:
        _send_vk_repeat(VK_BACK, backspace)
    if text:
        _send_unicode_text(text)
    return {"ok": True, "backspace": backspace, "sent": len(text)}

@app.post("/desktop/input/key")
def desktop_input_key(payload: Dict[str, Any] = Body(...)):
    _ensure_windows_host()
    key = (payload.get("key") or "").strip()
    if not key:
        raise HTTPException(status_code=400, detail="key is required.")
    r = _desktop_send_key(key)
    if r.get("exit_code") != 0:
        return {"ok": False, "error": "key_failed", "raw": r}
    return {"ok": True, "key": key}

# -------------------------
# Codex multi-session endpoints
# -------------------------
@app.post("/codex/session")
def codex_session_create(payload: Optional[Dict[str, Any]] = Body(default=None)):
    payload = payload or {}
    name_raw = (payload.get("name") or "").strip()
    if name_raw:
        name = _safe_name(name_raw)
        if not name.startswith("codex_"):
            name = f"codex_{name}"
    else:
        name = f"codex_{uuid.uuid4().hex[:8]}"
    _validate_session_name(name)

    cwd = (payload.get("cwd") or CODEX_WORKDIR).strip() or CODEX_WORKDIR
    cmd = f"tmux new-session -d -s {name} -c " + _bash_quote(cwd) + " 'codex'"
    r = run_wsl_bash(cmd, timeout_s=45)
    if r.get("exit_code") != 0:
        stderr = (r.get("stderr") or "").lower()
        if "duplicate session" in stderr or "session already exists" in stderr:
            return {"ok": False, "error": "session_exists", "detail": f"Session '{name}' already exists."}
        return {"ok": False, "error": "create_failed", "raw": r}

    with SESSIONS_LOCK:
        SESSIONS[name] = {
            "session": name,
            "cwd": cwd,
            "created_at": time.time(),
            "state": "starting",
            "last_text": "",
        }
    return {"ok": True, "session": name, "cwd": cwd}

@app.delete("/codex/session/{session}")
def codex_session_close(session: str):
    session = _validate_session_name(session)
    r = run_wsl_bash(f"tmux kill-session -t {session}", timeout_s=20)
    if r.get("exit_code") != 0:
        stderr = (r.get("stderr") or "").lower()
        if "can't find session" in stderr or "no such session" in stderr:
            return {"ok": False, "error": "not_found", "detail": f"Session '{session}' not found."}
        return {"ok": False, "error": "close_failed", "raw": r}
    with SESSIONS_LOCK:
        SESSIONS.pop(session, None)
    return {"ok": True, "session": session}

def _session_pane(session: str) -> Optional[Dict[str, Any]]:
    panes = _tmux_list_panes(session=session)
    if not panes:
        return None
    panes.sort(key=lambda p: p.get("active"), reverse=True)
    return panes[0]

@app.post("/codex/session/{session}/send")
def codex_session_send(session: str, text: str = Body(..., media_type="text/plain")):
    session = _validate_session_name(session)
    pane = _session_pane(session)
    if not pane:
        return {"ok": False, "error": "not_found", "detail": f"Session '{session}' has no panes."}
    # Codex TUI uses multi-line input by default:
    # - first Enter adds a newline
    # - an Enter on an empty line submits the prompt
    # Practical note: Codex doesn't always submit reliably when both Enters are sent back-to-back.
    # A tiny delay makes this deterministic across Windows -> wsl.exe -> tmux.
    cmd = (
        f"tmux send-keys -t {pane['pane_id']} -l " + _bash_quote(text) + " ; "
        f"tmux send-keys -t {pane['pane_id']} Enter ; "
        f"sleep 0.2 ; "
        f"tmux send-keys -t {pane['pane_id']} Enter"
    )
    p = run_wsl_bash(cmd, timeout_s=20)
    if p.get("exit_code") != 0:
        return {"ok": False, "error": "send_failed", "raw": p}
    return {"ok": True, "session": session}

@app.post("/codex/session/{session}/ctrlc")
def codex_session_ctrlc(session: str):
    session = _validate_session_name(session)
    pane = _session_pane(session)
    if not pane:
        return {"ok": False, "error": "not_found", "detail": f"Session '{session}' has no panes."}
    p = run_wsl_bash(f"tmux send-keys -t {pane['pane_id']} C-c", timeout_s=20)
    if p.get("exit_code") != 0:
        return {"ok": False, "error": "ctrlc_failed", "raw": p}
    return {"ok": True, "session": session}

@app.post("/codex/session/{session}/interrupt")
def codex_session_interrupt(session: str):
    """
    Interrupt Codex generation (preferred over Ctrl+C for the Codex TUI).
    Codex itself suggests: "esc to interrupt".
    """
    session = _validate_session_name(session)
    pane = _session_pane(session)
    if not pane:
        return {"ok": False, "error": "not_found", "detail": f"Session '{session}' has no panes."}
    p = run_wsl_bash(f"tmux send-keys -t {pane['pane_id']} Escape", timeout_s=20)
    if p.get("exit_code") != 0:
        return {"ok": False, "error": "interrupt_failed", "raw": p}
    return {"ok": True, "session": session}

@app.get("/codex/session/{session}/screen")
def codex_session_screen(session: str):
    session = _validate_session_name(session)
    pane = _session_pane(session)
    if not pane:
        return {"ok": False, "error": "not_found", "detail": f"Session '{session}' has no panes."}
    # Full pane capture is needed for Codex because it renders in the alternate screen.
    text = _capture_pane_full(pane["pane_id"], max_chars=25000)
    snippet = _capture_snippet(pane["pane_id"], lines=80)
    state = _infer_progress_state(text or snippet, pane.get("current_command", ""))
    with SESSIONS_LOCK:
        prev = SESSIONS.get(session, {})
        SESSIONS[session] = {
            **prev,
            "session": session,
            "state": state,
            "last_text": text or snippet,
            "updated_at": time.time(),
            "current_command": pane.get("current_command", ""),
        }
    return {
        "ok": True,
        "session": session,
        "pane_id": pane["pane_id"],
        "current_command": pane.get("current_command", ""),
        "state": state,
        "text": text or snippet,
    }

@app.get("/codex/sessions")
def codex_sessions_live():
    panes = _tmux_list_panes()
    live: List[Dict[str, Any]] = []
    now = time.time()
    for p in panes:
        session = p.get("session", "")
        cc = (p.get("current_command") or "").lower()
        known = session in SESSIONS
        codex_like = session.startswith("codex_") or cc == "codex"
        if not (known or codex_like):
            continue
        snippet = _capture_snippet(p["pane_id"], lines=60)
        state = _infer_progress_state(snippet, p.get("current_command", ""))
        item = {
            "session": session,
            "pane_id": p["pane_id"],
            "current_command": p.get("current_command", ""),
            "cwd": p.get("current_path", ""),
            "state": state,
            "updated_at": now,
            "snippet": snippet.splitlines()[-1] if snippet else "",
        }
        live.append(item)
        with SESSIONS_LOCK:
            prev = SESSIONS.get(session, {})
            SESSIONS[session] = {**prev, **item, "last_text": snippet}
    live.sort(key=lambda x: x["session"])
    return {"ok": True, "sessions": live}

@app.post("/codex/session/{session}/image")
async def codex_session_image(session: str, file: UploadFile = File(...), prompt: str = Form("")):
    session = _validate_session_name(session)
    pane = _session_pane(session)
    if not pane:
        return {"ok": False, "error": "not_found", "detail": f"Session '{session}' has no panes."}

    base_name = _safe_name(file.filename or "image")
    ts = int(time.time())
    rel = f".remote_uploads/{session}_{ts}_{base_name}"
    wsl_abs = posixpath.join(CODEX_WORKDIR.rstrip("/"), rel)
    unc = _wsl_unc_path(wsl_abs)
    os.makedirs(os.path.dirname(unc), exist_ok=True)
    with open(unc, "wb") as f:
        while True:
            chunk = await file.read(1024 * 1024)
            if not chunk:
                break
            f.write(chunk)

    msg = (prompt or "").strip()
    if msg:
        text = f"{msg}\n\nImage path: {wsl_abs}"
    else:
        text = f"Please inspect this image: {wsl_abs}"
    cmd = (
        f"tmux send-keys -t {pane['pane_id']} -l " + _bash_quote(text) + " ; "
        f"tmux send-keys -t {pane['pane_id']} Enter ; "
        f"sleep 0.2 ; "
        f"tmux send-keys -t {pane['pane_id']} Enter"
    )
    send = run_wsl_bash(cmd, timeout_s=20)
    if send.get("exit_code") != 0:
        return {"ok": False, "error": "send_failed", "saved_path": wsl_abs, "raw": send}
    return {"ok": True, "session": session, "saved_path": wsl_abs}

def _legacy_result_page(title: str, payload: Dict[str, Any], status_code: int = 200) -> HTMLResponse:
    pretty = html_std.escape(json.dumps(payload, ensure_ascii=False, indent=2))
    safe_title = html_std.escape(title or "Result")
    content = f"""
<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>{safe_title}</title>
    <style>
      body {{
        margin: 0;
        padding: 16px;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        background: #f8fafc;
        color: #0f172a;
      }}
      .card {{
        background: #fff;
        border: 1px solid #dfe4ea;
        border-radius: 12px;
        padding: 14px;
      }}
      pre {{
        margin: 0;
        white-space: pre-wrap;
        background: #0b0d12;
        color: #e5e7eb;
        padding: 12px;
        border-radius: 10px;
        border: 1px solid #1f2937;
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      }}
      a {{
        display: inline-block;
        margin-top: 12px;
        color: #0b4f6c;
      }}
    </style>
  </head>
  <body>
    <div class="card">
      <h2 style="margin-top: 0;">{safe_title}</h2>
      <pre>{pretty}</pre>
      <a href="/">Back to controller</a>
    </div>
  </body>
</html>
    """.strip()
    return HTMLResponse(content=content, status_code=status_code, headers={"Cache-Control": "no-store"})

def _legacy_truthy(v: Any) -> bool:
    return _truthy_flag(v)

def _legacy_error_payload(exc: Exception) -> Dict[str, Any]:
    if isinstance(exc, HTTPException):
        return {
            "ok": False,
            "error": "http_error",
            "detail": getattr(exc, "detail", "request failed"),
            "status_code": getattr(exc, "status_code", 400),
        }
    return {"ok": False, "error": "exception", "detail": f"{type(exc).__name__}: {exc}"}

@app.post("/legacy/desktop/mode")
def legacy_desktop_mode(enabled: str = Form(""), next: str = Form("/")):
    on = _truthy_flag(enabled)
    resp = Response(status_code=303, headers={"Location": _safe_next_path(next)})
    resp.set_cookie(
        key=CODEX_DESKTOP_MODE_COOKIE,
        value="1" if on else "0",
        httponly=True,
        secure=False,
        samesite="lax",
        max_age=60 * 60 * 24 * 30,
    )
    return resp

@app.post("/legacy/desktop/click")
def legacy_desktop_click(
    button: str = Form("left"),
    double: str = Form("0"),
    x: str = Form(""),
    y: str = Form(""),
):
    payload: Dict[str, Any] = {"button": (button or "left").strip().lower(), "double": _legacy_truthy(double)}
    xs = (x or "").strip()
    ys = (y or "").strip()
    if xs or ys:
        if not xs or not ys:
            return _legacy_result_page(
                "Desktop Click",
                {"ok": False, "error": "bad_request", "detail": "x and y must be provided together."},
                400,
            )
        try:
            payload["x"] = int(xs)
            payload["y"] = int(ys)
        except ValueError:
            return _legacy_result_page(
                "Desktop Click",
                {"ok": False, "error": "bad_request", "detail": "x and y must be integers."},
                400,
            )
    try:
        out = desktop_input_click(payload)
    except Exception as e:
        err = _legacy_error_payload(e)
        status = int(err.get("status_code") or 400)
        return _legacy_result_page("Desktop Click", err, status)
    return _legacy_result_page("Desktop Click", out, 200 if out.get("ok") else 400)

@app.post("/legacy/desktop/tap")
def legacy_desktop_tap(
    tap_x: Optional[int] = Form(default=None, alias="tap.x"),
    tap_y: Optional[int] = Form(default=None, alias="tap.y"),
    x: Optional[int] = Form(default=None),
    y: Optional[int] = Form(default=None),
    render_w: int = Form(0),
    render_h: int = Form(0),
    button: str = Form("left"),
    double: str = Form("0"),
):
    px = tap_x if tap_x is not None else x
    py = tap_y if tap_y is not None else y
    if px is None or py is None:
        return _legacy_result_page(
            "Desktop Tap Click",
            {"ok": False, "error": "bad_request", "detail": "Tap coordinates are required."},
            400,
        )
    try:
        tx = int(px)
        ty = int(py)
        mon = _desktop_monitor()
        native_w = max(1, int(mon.get("width") or 1))
        native_h = max(1, int(mon.get("height") or 1))
        rw = int(render_w or 0)
        rh = int(render_h or 0)
        if rw > 0 and rh > 0:
            tx = int(round((tx * native_w) / rw))
            ty = int(round((ty * native_h) / rh))
        tx = _clamp(tx, 0, native_w - 1)
        ty = _clamp(ty, 0, native_h - 1)
        out = desktop_input_click(
            {
                "x": tx,
                "y": ty,
                "button": (button or "left").strip().lower(),
                "double": _legacy_truthy(double),
            }
        )
    except Exception as e:
        err = _legacy_error_payload(e)
        status = int(err.get("status_code") or 400)
        return _legacy_result_page("Desktop Tap Click", err, status)
    return _legacy_result_page("Desktop Tap Click", out, 200 if out.get("ok") else 400)

@app.post("/legacy/desktop/scroll")
def legacy_desktop_scroll(delta: int = Form(0)):
    if int(delta) == 0:
        return _legacy_result_page(
            "Desktop Scroll",
            {"ok": False, "error": "bad_request", "detail": "delta is required."},
            400,
        )
    try:
        out = desktop_input_scroll({"delta": int(delta)})
    except Exception as e:
        err = _legacy_error_payload(e)
        status = int(err.get("status_code") or 400)
        return _legacy_result_page("Desktop Scroll", err, status)
    return _legacy_result_page("Desktop Scroll", out, 200 if out.get("ok") else 400)

@app.post("/legacy/desktop/key")
def legacy_desktop_key(key: str = Form("")):
    if not (key or "").strip():
        return _legacy_result_page(
            "Desktop Key",
            {"ok": False, "error": "bad_request", "detail": "key is required."},
            400,
        )
    try:
        out = desktop_input_key({"key": key})
    except Exception as e:
        err = _legacy_error_payload(e)
        status = int(err.get("status_code") or 400)
        return _legacy_result_page("Desktop Key", err, status)
    return _legacy_result_page("Desktop Key", out, 200 if out.get("ok") else 400)

@app.post("/legacy/desktop/text")
def legacy_desktop_text(text: str = Form("")):
    t = text or ""
    if not t.strip():
        return _legacy_result_page(
            "Desktop Text",
            {"ok": False, "error": "bad_request", "detail": "text is required."},
            400,
        )
    try:
        out = desktop_input_type({"text": t})
    except Exception as e:
        err = _legacy_error_payload(e)
        status = int(err.get("status_code") or 400)
        return _legacy_result_page("Desktop Text", err, status)
    return _legacy_result_page("Desktop Text", out, 200 if out.get("ok") else 400)

@app.post("/legacy/codex/create")
def legacy_codex_create(name: str = Form(""), cwd: str = Form("")):
    payload: Dict[str, Any] = {}
    if (name or "").strip():
        payload["name"] = name.strip()
    if (cwd or "").strip():
        payload["cwd"] = cwd.strip()
    out = codex_session_create(payload)
    return _legacy_result_page("Create Codex Session", out, 200 if out.get("ok") else 400)

@app.post("/legacy/codex/send")
def legacy_codex_send(session: str = Form(""), text: str = Form("")):
    session = (session or "").strip()
    text = text or ""
    if not session:
        return _legacy_result_page("Send Prompt", {"ok": False, "error": "bad_request", "detail": "session is required"}, 400)
    if not text.strip():
        return _legacy_result_page("Send Prompt", {"ok": False, "error": "bad_request", "detail": "text is required"}, 400)
    out = codex_session_send(session, text)
    return _legacy_result_page("Send Prompt", out, 200 if out.get("ok") else 400)

@app.post("/legacy/codex/interrupt")
def legacy_codex_interrupt(session: str = Form("")):
    session = (session or "").strip()
    if not session:
        return _legacy_result_page("Interrupt Session", {"ok": False, "error": "bad_request", "detail": "session is required"}, 400)
    out = codex_session_interrupt(session)
    return _legacy_result_page("Interrupt Session", out, 200 if out.get("ok") else 400)

@app.post("/legacy/codex/close")
def legacy_codex_close(session: str = Form("")):
    session = (session or "").strip()
    if not session:
        return _legacy_result_page("Close Session", {"ok": False, "error": "bad_request", "detail": "session is required"}, 400)
    out = codex_session_close(session)
    return _legacy_result_page("Close Session", out, 200 if out.get("ok") else 400)

@app.get("/legacy/codex/screen")
def legacy_codex_screen(session: str = ""):
    session = (session or "").strip()
    if not session:
        return _legacy_result_page("Session Screen", {"ok": False, "error": "bad_request", "detail": "session is required"}, 400)
    out = codex_session_screen(session)
    if not out.get("ok"):
        return _legacy_result_page("Session Screen", out, 400)
    state = html_std.escape(str(out.get("state", "")))
    cmd = html_std.escape(str(out.get("current_command", "")))
    text = html_std.escape(str(out.get("text") or ""))
    safe_session = html_std.escape(session)
    content = f"""
<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Session Screen - {safe_session}</title>
    <style>
      body {{
        margin: 0;
        padding: 16px;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        background: #f8fafc;
        color: #0f172a;
      }}
      .meta {{
        margin-bottom: 10px;
        color: #475569;
        font-size: 13px;
      }}
      pre {{
        white-space: pre-wrap;
        background: #0b0d12;
        color: #e5e7eb;
        padding: 12px;
        border-radius: 10px;
        border: 1px solid #1f2937;
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      }}
      a {{
        display: inline-block;
        margin-top: 12px;
        color: #0b4f6c;
      }}
    </style>
  </head>
  <body>
    <h2 style="margin: 0 0 6px;">Session Screen: {safe_session}</h2>
    <div class="meta">state: {state} | cmd: {cmd}</div>
    <pre>{text}</pre>
    <a href="/">Back to controller</a>
  </body>
</html>
    """.strip()
    return HTMLResponse(content=content, headers={"Cache-Control": "no-store"})

# -------------------------
# Screenshot endpoint
# -------------------------
@app.get("/shot")
def shot():
    with mss() as sct:
        mon = sct.monitors[1]
        img = sct.grab(mon)
        png_bytes = to_png(img.rgb, img.size)
        return Response(
            content=png_bytes,
            media_type="image/png",
            headers={"Cache-Control": "no-store"},
        )

# -------------------------
# tmux endpoints
# -------------------------
def _sse_event_bytes(event: str, payload: Dict[str, Any]) -> bytes:
    """
    Minimal Server-Sent Events (SSE) encoder.

    Notes:
    - We send JSON on a single `data:` line. Newlines in `text` become `\\n` escapes.
    - This keeps the client-side parser simple and avoids multi-line SSE edge cases.
    """
    ev = (event or "message").replace("\n", " ").replace("\r", " ").strip() or "message"
    try:
        data = json.dumps(payload, ensure_ascii=False, separators=(",", ":"))
    except Exception:
        data = json.dumps({"ok": False, "error": "sse_encode_failed"}, separators=(",", ":"))
    return f"event: {ev}\ndata: {data}\n\n".encode("utf-8")

def _attach_repr(payload: Dict[str, Any]) -> Dict[str, Any]:
    out = dict(payload)
    out["stdout_repr"] = repr(out.get("stdout") or "")
    out["stderr_repr"] = repr(out.get("stderr") or "")
    return out

@app.get("/tmux/debug")
def tmux_debug():
    checks = {
        "whoami": _attach_repr(run_wsl_bash("whoami")),
        "pwd": _attach_repr(run_wsl_bash("pwd")),
        "tmux_version": _attach_repr(run_wsl_bash("tmux -V")),
        "list_sessions": _attach_repr(run_wsl_bash(
            "tmux list-sessions -F '#{session_name}\\t#{session_id}\\t#{session_created}'"
        )),
        "list_panes": _attach_repr(run_wsl_bash(
            "tmux list-panes -a -F '#{session_name}\\t#{window_index}\\t#{pane_index}\\t#{pane_id}\\t#{pane_active}\\t#{pane_current_command}\\t#{pane_current_path}'"
        )),
    }
    return {
        "ok": True,
        "wsl_exe": _wsl_executable(),
        "distro": WSL_DISTRO,
        "checks": checks,
    }

@app.get("/tmux/health")
def tmux_health():
    r = run_wsl_bash("tmux list-sessions -F '#{session_name}'")
    if r["exit_code"] == 0:
        sessions = sorted({line.strip() for line in (r.get("stdout") or "").splitlines() if line.strip()})
        return {"ok": True, "state": "ok" if sessions else "empty", "count": len(sessions), "sessions": sessions}

    if not _tmux_server_running(r.get("stderr") or ""):
        return {"ok": True, "state": "no_server", "count": 0, "sessions": [], "raw": r}

    return {"ok": False, "error": "tmux_error", "raw": r}

@app.post("/tmux/session")
def tmux_create_session(payload: Optional[Dict[str, Any]] = Body(default=None)):
    payload = payload or {}
    name = (payload.get("name") or "").strip()
    if name:
        _validate_session_name(name)
        cmd = "tmux new-session -d -s " + name
    else:
        cmd = "tmux new-session -d"

    r = run_wsl_bash(cmd)
    if r["exit_code"] == 0:
        return {"ok": True, "name": name or None}

    stderr_lower = (r.get("stderr") or "").lower()
    if "duplicate session" in stderr_lower or "session already exists" in stderr_lower:
        return {"ok": False, "error": "session_exists", "detail": f"Session '{name}' already exists.", "raw": r}

    return {"ok": False, "error": "create_failed", "raw": r}

@app.delete("/tmux/session/{session}")
def tmux_close_session(session: str):
    session = _validate_session_name(session)
    r = run_wsl_bash(f"tmux kill-session -t {session}")

    if r["exit_code"] == 0:
        return {"ok": True, "session": session}

    stderr_lower = (r.get("stderr") or "").lower()
    if "can't find session" in stderr_lower or "no such session" in stderr_lower:
        return {"ok": False, "error": "not_found", "detail": f"Session '{session}' not found.", "raw": r}

    if not _tmux_server_running(r.get("stderr") or ""):
        return {"ok": False, "error": "tmux_server_not_running", "raw": r}

    return {"ok": False, "error": "close_failed", "raw": r}

@app.get("/tmux/panes")
def tmux_panes(session: Optional[str] = None):
    if session:
        _validate_session_name(session)
        cmd = (
            "tmux list-panes -t " + session +
            " -F '#{session_name}\t#{window_index}\t#{pane_index}\t#{pane_id}\t#{pane_active}\t#{pane_current_command}\t#{pane_current_path}'"
        )
    else:
        cmd = (
            "tmux list-panes -a "
            "-F '#{session_name}\t#{window_index}\t#{pane_index}\t#{pane_id}\t#{pane_active}\t#{pane_current_command}\t#{pane_current_path}'"
        )

    r = run_wsl_bash(cmd)
    panes: List[Dict[str, Any]] = []

    if r["exit_code"] == 0:
        if r["stdout"]:
            for line in r["stdout"].splitlines():
                # tmux may emit literal "\t" sequences; normalize to real tabs.
                parts = line.replace("\\t", "\t").split("\t")
                if len(parts) >= 7:
                    panes.append({
                        "session": parts[0],
                        "window_index": parts[1],
                        "pane_index": parts[2],
                        "pane_id": parts[3],
                        "active": parts[4] == "1",
                        "current_command": parts[5],
                        "current_path": parts[6],
                    })
        return {"ok": True, "panes": panes}

    stderr_lower = (r["stderr"] or "").lower()
    if "no server running" in stderr_lower or "failed to connect to server" in stderr_lower:
        return {"ok": True, "panes": []}

    return {"ok": False, "panes": [], "raw": r}

@app.get("/tmux/pane/{pane_id}/screen")
def pane_screen(pane_id: str):
    pane_id = _validate_pane_id(pane_id)

    # Try alternate-screen first, then fallback.
    r = run_wsl_bash(f"tmux capture-pane -t {pane_id} -a -p -J", timeout_s=30)
    if r["exit_code"] != 0 and ("no alternate screen" in (r.get("stderr") or "").lower()):
        r = run_wsl_bash(f"tmux capture-pane -t {pane_id} -p -J -S -20000", timeout_s=30)

    if r["exit_code"] == 0:
        return {"ok": True, "pane_id": pane_id, "text": r["stdout"]}

    if not _tmux_server_running(r.get("stderr") or ""):
        return {"ok": False, "error": "tmux_server_not_running", "raw": r}

    return {"ok": False, "error": "capture_failed", "raw": r}

def _stream_capture_pane_text(pane_id: str, max_chars: int) -> Dict[str, Any]:
    """
    Capture the tmux pane as plain text (alternate-screen preferred).
    Returns the same shape as `/tmux/pane/{pane_id}/screen` for easy client reuse.
    """
    pane_id = _validate_pane_id(pane_id)
    max_chars = int(max_chars or 0)
    if max_chars < 2000:
        max_chars = 2000
    if max_chars > 100_000:
        max_chars = 100_000

    r = run_wsl_bash(f"tmux capture-pane -t {pane_id} -a -p -J", timeout_s=30)
    if r.get("exit_code") != 0 and ("no alternate screen" in (r.get("stderr") or "").lower()):
        r = run_wsl_bash(f"tmux capture-pane -t {pane_id} -p -J -S -20000", timeout_s=30)

    if r.get("exit_code") == 0:
        text = r.get("stdout") or ""
        if max_chars and len(text) > max_chars:
            text = text[-max_chars:]
        return {"ok": True, "pane_id": pane_id, "text": text}

    if not _tmux_server_running(r.get("stderr") or ""):
        return {"ok": False, "error": "tmux_server_not_running", "raw": r}

    return {"ok": False, "error": "capture_failed", "raw": r}

@app.get("/tmux/pane/{pane_id}/stream")
async def pane_stream(request: Request, pane_id: str, interval_ms: int = 800, max_chars: int = 25000):
    """
    SSE stream of a tmux pane's captured screen text.

    This is *not* a full terminal emulator; it pushes periodic `capture-pane` snapshots.
    It's fast, works on Windows+WSL, and is good enough for watching Codex output live.
    """
    pane_id = _validate_pane_id(pane_id)
    try:
        interval_ms = int(interval_ms or 800)
    except Exception:
        interval_ms = 800
    interval_ms = max(200, min(interval_ms, 5000))
    try:
        max_chars = int(max_chars or 25000)
    except Exception:
        max_chars = 25000

    async def _gen():
        yield _sse_event_bytes("hello", {"ok": True, "pane_id": pane_id, "interval_ms": interval_ms, "max_chars": max_chars})
        last_text: Optional[str] = None
        last_send = 0.0
        seq = 0
        while True:
            if await request.is_disconnected():
                break

            snap = await asyncio.to_thread(_stream_capture_pane_text, pane_id, max_chars)
            if not snap.get("ok"):
                yield _sse_event_bytes("error", {"ok": False, "pane_id": pane_id, "ts": time.time(), **snap})
                # Slow down on errors to avoid hammering wsl.exe / tmux.
                await asyncio.sleep(max(1.5, interval_ms / 1000.0))
                continue

            text = snap.get("text") or ""
            if text != last_text:
                last_text = text
                seq += 1
                yield _sse_event_bytes("screen", {"ok": True, "pane_id": pane_id, "seq": seq, "ts": time.time(), "text": text})
                last_send = time.time()
            else:
                # Keep the connection alive (mobile networks, proxies).
                if time.time() - last_send > 10:
                    yield _sse_event_bytes("ping", {"ok": True, "pane_id": pane_id, "ts": time.time()})
                    last_send = time.time()

            await asyncio.sleep(interval_ms / 1000.0)

    headers = {
        "Cache-Control": "no-cache",
        "Connection": "keep-alive",
        # Disables proxy buffering when deployed behind nginx; harmless elsewhere.
        "X-Accel-Buffering": "no",
    }
    return StreamingResponse(_gen(), media_type="text/event-stream", headers=headers)

@app.post("/tmux/pane/{pane_id}/send")
def pane_send(pane_id: str, text: str = Body(..., media_type="text/plain")):
    pane_id = _validate_pane_id(pane_id)
    if len(text) > 8000:
        raise HTTPException(status_code=400, detail="Text too long (max 8000 chars).")

    # If this pane looks like a Codex session, submit using the Codex-friendly
    # "blank-line Enter" flow (with a tiny delay).
    if _pane_is_codex_like(pane_id):
        cmd = (
            f"tmux send-keys -t {pane_id} -l " + _bash_quote(text) + " ; "
            f"tmux send-keys -t {pane_id} Enter ; "
            f"sleep 0.2 ; "
            f"tmux send-keys -t {pane_id} Enter"
        )
    else:
        cmd = (
            f"tmux send-keys -t {pane_id} -l " + _bash_quote(text) + " \\; " +
            f"send-keys -t {pane_id} Enter"
        )
    r = run_wsl_bash(cmd, timeout_s=30)

    if r["exit_code"] == 0:
        return {"ok": True, "pane_id": pane_id}

    if not _tmux_server_running(r.get("stderr") or ""):
        return {"ok": False, "error": "tmux_server_not_running", "raw": r}

    return {"ok": False, "error": "send_failed", "raw": r}

@app.post("/tmux/pane/{pane_id}/ctrlc")
def pane_ctrlc(pane_id: str):
    pane_id = _validate_pane_id(pane_id)
    # For Codex panes, Esc is the safe "interrupt" key. Ctrl+C can terminate the TUI.
    key = "Escape" if _pane_is_codex_like(pane_id) else "C-c"
    r = run_wsl_bash(f"tmux send-keys -t {pane_id} {key}", timeout_s=20)

    if r["exit_code"] == 0:
        return {"ok": True, "pane_id": pane_id, "sent": "esc" if key == "Escape" else "ctrl+c"}

    if not _tmux_server_running(r.get("stderr") or ""):
        return {"ok": False, "error": "tmux_server_not_running", "raw": r}

    return {"ok": False, "error": "ctrlc_failed", "raw": r}

# -------------------------
# WSL file endpoints
# -------------------------
@app.get("/wsl/file")
def wsl_file(path: str):
    wsl_abs = _resolve_wsl_path(path)
    unc = _wsl_unc_path(wsl_abs)

    if not os.path.exists(unc):
        raise HTTPException(status_code=404, detail="File not found.")
    if os.path.isdir(unc):
        raise HTTPException(status_code=400, detail="Path is a directory. Provide a file path.")

    # Stream the file via UNC path (supports binary)
    filename = os.path.basename(wsl_abs.rstrip("/"))
    return FileResponse(unc, filename=filename)

@app.post("/wsl/upload")
async def wsl_upload(file: UploadFile = File(...), dest: str = Form("")):
    # dest is relative to CODEX_FILE_ROOT; if blank, use original filename.
    rel = (dest or "").strip()
    if not rel:
        rel = file.filename or "upload.bin"

    wsl_abs = _resolve_wsl_path(rel)
    unc = _wsl_unc_path(wsl_abs)

    # ensure directory exists
    unc_dir = os.path.dirname(unc)
    os.makedirs(unc_dir, exist_ok=True)

    # write in chunks
    try:
        with open(unc, "wb") as f:
            while True:
                chunk = await file.read(1024 * 1024)
                if not chunk:
                    break
                f.write(chunk)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to write file: {type(e).__name__}: {e}")

    return {"ok": True, "saved_path": wsl_abs}

# -------------------------
# codex exec endpoints
# -------------------------
def _count_running_runs() -> int:
    with RUNS_LOCK:
        return sum(1 for rr in RUNS.values() if rr.get("status") == "running")

def _store_run(run_id: str, run: Dict[str, Any]) -> None:
    with RUNS_LOCK:
        RUNS[run_id] = run
        RUNS_ORDER.insert(0, run_id)
        while len(RUNS_ORDER) > MAX_RUNS_KEEP:
            old = RUNS_ORDER.pop()
            RUNS.pop(old, None)

def _run_codex_exec_in_thread(run_id: str, prompt: str):
    start = time.time()
    cmd = f"codex exec --cd {CODEX_WORKDIR} " + _bash_quote(prompt)
    r = run_wsl_bash(cmd, timeout_s=900)

    duration = round(time.time() - start, 1)
    output_parts = []
    if r.get("stdout"):
        output_parts.append(r["stdout"])
    if r.get("stderr"):
        output_parts.append("\n[stderr]\n" + r["stderr"])
    output = "\n".join(output_parts).strip()

    with RUNS_LOCK:
        rr = RUNS.get(run_id, {})
        rr["status"] = "done" if r.get("exit_code") == 0 else "error"
        rr["exit_code"] = r.get("exit_code")
        rr["duration_s"] = duration
        rr["output"] = output
        rr["finished_at"] = time.time()
        RUNS[run_id] = rr

@app.post("/codex/exec")
def codex_exec(payload: Dict[str, Any] = Body(...)):
    prompt = (payload.get("prompt") or "").strip()
    if not prompt:
        raise HTTPException(status_code=400, detail="Missing prompt.")
    if len(prompt) > 20000:
        raise HTTPException(status_code=400, detail="Prompt too long (max 20000 chars).")

    if _count_running_runs() >= MAX_CONCURRENT_RUNS:
        return {"ok": False, "error": "too_many_running", "detail": f"Max concurrent runs is {MAX_CONCURRENT_RUNS}."}

    run_id = uuid.uuid4().hex[:10]
    run = {
        "id": run_id,
        "status": "running",
        "prompt": prompt,
        "created_at": time.time(),
        "output": "",
        "exit_code": None,
        "duration_s": None,
    }
    _store_run(run_id, run)

    t = threading.Thread(target=_run_codex_exec_in_thread, args=(run_id, prompt), daemon=True)
    t.start()

    return {"ok": True, "id": run_id}

@app.get("/codex/run/{run_id}")
def codex_run(run_id: str):
    with RUNS_LOCK:
        rr = RUNS.get(run_id)
        if not rr:
            return {"ok": False, "error": "not_found"}
        return {"ok": True, **rr}

@app.get("/codex/runs")
def codex_runs():
    with RUNS_LOCK:
        items = []
        for rid in RUNS_ORDER[:20]:
            rr = RUNS.get(rid, {})
            items.append({
                "id": rr.get("id"),
                "status": rr.get("status"),
                "duration_s": rr.get("duration_s"),
                "prompt": rr.get("prompt", ""),
            })
        return {"ok": True, "runs": items}
